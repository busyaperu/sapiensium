{"id": "3a0058c5", "examenData": {"examen_id": "925268", "nombre_examen": "Arquitecturas Reactivas", "tipo_examen": "Evaluaci\u00f3n", "fecha": "2025-05-22T15:25:30.149Z", "nombre_profesor": "Mariela Isabel Camargo Rom\u00e1n", "profesor_id": "16MI987", "preguntas_marcar": [{"numero": 1, "texto": "\u00bfQu\u00e9 patr\u00f3n de dise\u00f1o se utiliza frecuentemente en arquitecturas reactivas para manejar la concurrencia de manera eficiente?\nA) Singleton\nB) Factory\nC) Actor\nD) Observer\nE) Template Method", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 3}, {"numero": 2, "texto": "\u00bfCu\u00e1l es la principal ventaja de utilizar un backpressure en un sistema reactivo?\nA) Mayor velocidad de procesamiento\nB) Menor latencia\nC) Prevenci\u00f3n de sobrecarga del sistema\nD) Mejor manejo de errores\nE) Simplificaci\u00f3n del c\u00f3digo", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 2}], "preguntas_libres": [{"numero": 3, "texto": "Explique c\u00f3mo se implementar\u00eda la tolerancia a fallos en una arquitectura reactiva utilizando patrones como el Circuit Breaker y la gesti\u00f3n de backpressure.  Proporcione ejemplos concretos.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "## Implementando Tolerancia a Fallos en una Arquitectura Reactiva\n\nLa tolerancia a fallos es un pilar fundamental en las arquitecturas reactivas, garantizando la resiliencia del sistema ante errores y manteniendo la capacidad de respuesta.  Dos patrones clave para lograr esto son el Circuit Breaker y la gesti\u00f3n de backpressure.\n\n**1. Circuit Breaker:**\n\nEl patr\u00f3n Circuit Breaker previene la cascada de fallos al detener las solicitudes a un servicio que se sabe que est\u00e1 fallando.  Funciona como un interruptor el\u00e9ctrico:\n\n* **Estado Cerrado:**  El circuito est\u00e1 cerrado y las solicitudes fluyen normalmente hacia el servicio.  Se monitoriza el n\u00famero de fallos.\n* **Estado Abierto:** Si el n\u00famero de fallos supera un umbral predefinido en un periodo de tiempo, el circuito se abre.  Las nuevas solicitudes se rechazan inmediatamente con un error, evitando la sobrecarga del servicio fallido y dando tiempo para su recuperaci\u00f3n.\n* **Estado Semi-Abierto:** Despu\u00e9s de un tiempo predefinido en estado abierto, el circuito pasa a semi-abierto.  Se permite un n\u00famero limitado de solicitudes para probar si el servicio se ha recuperado. Si estas solicitudes son exitosas, el circuito vuelve al estado cerrado.  Si fallan, el circuito vuelve al estado abierto y el temporizador se reinicia.\n\n**Ejemplo Concreto (Java con Hystrix, aunque el concepto es aplicable a otros lenguajes y bibliotecas):**\n\n```java\nHystrixCommand<String> command = new HystrixCommand<String>(setter) {\n    @Override\n    protected String run() throws Exception {\n        // L\u00f3gica para llamar al servicio externo\n        return servicioExterno.obtenerDatos();\n    }\n\n    @Override\n    protected String getFallback() {\n        // L\u00f3gica de fallback en caso de fallo\n        return \"Datos por defecto\";\n    }\n};\n\nString resultado = command.execute();\n```\n\nEn este ejemplo, `HystrixCommand` implementa el patr\u00f3n Circuit Breaker.  `run()` contiene la l\u00f3gica para llamar al servicio externo.  `getFallback()` proporciona una respuesta alternativa en caso de fallo (estado abierto o semi-abierto).  Hystrix gestiona autom\u00e1ticamente los estados del circuito y las m\u00e9tricas de fallos.\n\n\n**2. Gesti\u00f3n de Backpressure:**\n\nLa backpressure es un mecanismo para controlar el flujo de datos entre un productor y un consumidor, evitando que el productor sobrecargue al consumidor.  En lugar de dejar que el consumidor falle bajo presi\u00f3n, la backpressure permite que el consumidor comunique al productor que reduzca la velocidad de env\u00edo de datos.\n\nExisten diferentes estrategias para implementar backpressure:\n\n* **Buffering:** El consumidor almacena los datos en un buffer hasta que puede procesarlos.  Esta estrategia es \u00fatil para picos de carga cortos, pero puede llevar a problemas de memoria si el productor env\u00eda datos continuamente a una velocidad mayor que la que el consumidor puede procesar.\n* **Dropping:** El consumidor descarta los datos que no puede procesar inmediatamente.  Esta estrategia es \u00fatil cuando la p\u00e9rdida de algunos datos es aceptable.\n* **Flow Control:** El consumidor solicita expl\u00edcitamente al productor que env\u00ede una cantidad espec\u00edfica de datos.  Esta estrategia ofrece un control m\u00e1s preciso sobre el flujo de datos.\n\n\n**Ejemplo Concreto (Reactor en Java):**\n\n```java\nFlux<Data> dataStream = servicioExterno.getDataStream();\n\ndataStream\n    .onBackpressureBuffer(10, data -> log.warn(\"Buffer overflow, dropping data: {}\", data))\n    .subscribe(data -> procesarData(data));\n```\n\nEn este ejemplo, `onBackpressureBuffer` implementa una estrategia de backpressure con buffering.  Se define un buffer de tama\u00f1o 10. Si el buffer se llena, los nuevos datos se descartan y se registra un mensaje de advertencia.  Otras estrategias como `onBackpressureDrop` y `onBackpressureLatest` tambi\u00e9n est\u00e1n disponibles.\n\n**Conclusi\u00f3n:**\n\nCombinando Circuit Breaker y backpressure, se construye una arquitectura reactiva robusta y tolerante a fallos.  El Circuit Breaker previene la cascada de fallos aislando los servicios problem\u00e1ticos, mientras que la backpressure gestiona el flujo de datos entre componentes, evitando la sobrecarga y manteniendo la capacidad de respuesta del sistema.  La elecci\u00f3n de la estrategia de backpressure depende de las necesidades espec\u00edficas de la aplicaci\u00f3n, considerando la tolerancia a la p\u00e9rdida de datos y los recursos disponibles.  Utilizar bibliotecas como Hystrix (para Circuit Breaker) y Reactor (para backpressure y programaci\u00f3n reactiva) simplifica la implementaci\u00f3n de estos patrones y facilita la construcci\u00f3n de sistemas resilientes.\n"}], "casos_uso": [{"numero": 4, "descripcion": "-   **Escenario pr\u00e1ctico detallado:** Un sistema de agregaci\u00f3n de datos de redes sociales que consume flujos masivos y continuos de publicaciones, comentarios y \"me gusta\" de diversas plataformas. El sistema necesita filtrar, procesar, analizar el sentimiento en tiempo real y almacenar los datos relevantes, manteniendo la capacidad de respuesta a consultas de an\u00e1lisis a pesar del volumen y la velocidad de entrada de datos.\n    -   **Requisitos espec\u00edficos de lo que debe implementar el estudiante:** El estudiante debe generar 2 preguntas espec\u00edficas y perspicaces sobre la aplicaci\u00f3n de principios de arquitecturas reactivas en este escenario particular. Las preguntas deben explorar desaf\u00edos, soluciones o consideraciones clave relacionadas con la reactividad (Respuesta R\u00e1pida, Resiliencia, Elasticidad, Orientaci\u00f3n a Mensajes) dentro del contexto de procesamiento de flujos de datos de redes sociales.\n    -   **Sugerencias de herramientas o enfoques que podr\u00eda utilizar:** Enfocarse en el manejo de backpressure cuando los componentes de procesamiento o an\u00e1lisis son m\u00e1s lentos que la ingesta de datos, la resiliencia ante fallos en las APIs de las redes sociales o en los servicios de an\u00e1lisis, la escalabilidad para manejar el crecimiento del volumen de datos y la latencia en la entrega de resultados de an\u00e1lisis en tiempo real. Considerar el uso de colas de mensajes o sistemas de streaming como Kafka o Kinesis.", "pregunta": "Desarrolle una soluci\u00f3n para el caso descrito anteriormente", "puntaje": 17, "respuestaAlumno": "", "archivoSubido": false, "respuestaProfesor": "## Soluci\u00f3n: Preguntas sobre Arquitecturas Reactivas para un Sistema de Agregaci\u00f3n de Datos de Redes Sociales\n\nEste caso pr\u00e1ctico presenta el desaf\u00edo de construir un sistema reactivo para agregar datos de redes sociales.  El volumen, velocidad y variedad de datos, junto con la necesidad de an\u00e1lisis en tiempo real, demandan una arquitectura robusta y escalable. Para evaluar la comprensi\u00f3n de los principios reactivos, se proponen las siguientes dos preguntas:\n\n**Pregunta 1:  Manejo de Backpressure y Resiliencia**\n\nConsiderando la naturaleza impredecible de los flujos de datos de redes sociales (picos de actividad, interrupciones de APIs, etc.), \u00bfc\u00f3mo se implementar\u00eda una estrategia efectiva de backpressure en este sistema para evitar la sobrecarga de los componentes de procesamiento y an\u00e1lisis?  Espec\u00edficamente, describe c\u00f3mo se integrar\u00eda un mecanismo de backpressure con un sistema de streaming como Kafka o Kinesis para garantizar la resiliencia del sistema ante fluctuaciones en la velocidad de ingesta y procesamiento de datos.  \u00bfQu\u00e9 mecanismos de control de flujo y estrategias de reintentos se considerar\u00edan para manejar los mensajes no procesados durante periodos de alta carga?\n\n\n**Justificaci\u00f3n:**\n\nEsta pregunta explora la capacidad del estudiante para aplicar los principios de *Respuesta R\u00e1pida* y *Resiliencia*. Un sistema reactivo debe ser capaz de manejar la carga fluctuante sin colapsar.  La pregunta se centra en la gesti\u00f3n de backpressure, un concepto crucial para evitar la sobrecarga del sistema cuando la velocidad de ingesta supera la capacidad de procesamiento.  Adem\u00e1s, obliga al estudiante a considerar la integraci\u00f3n con tecnolog\u00edas de streaming comunes y a proponer mecanismos concretos de control de flujo y reintentos.\n\n\n**Pregunta 2: Elasticidad y Latencia en An\u00e1lisis de Sentimiento en Tiempo Real**\n\nEl an\u00e1lisis de sentimiento en tiempo real es un requisito clave de este sistema.  Considerando la necesidad de *Elasticidad* para adaptarse a la demanda fluctuante y la importancia de una baja latencia para la entrega de resultados, \u00bfc\u00f3mo se dise\u00f1ar\u00eda la arquitectura del componente de an\u00e1lisis de sentimiento? \u00bfQu\u00e9 estrategias de escalado autom\u00e1tico (horizontal o vertical) se implementar\u00edan para asegurar que el sistema pueda manejar picos de actividad sin comprometer la velocidad de respuesta?  \u00bfQu\u00e9 tecnolog\u00edas o frameworks (e.g., Spark Streaming, Flink) ser\u00edan adecuadas para este escenario y por qu\u00e9?  \u00bfC\u00f3mo se minimizar\u00eda la latencia en el procesamiento y la entrega de los resultados del an\u00e1lisis de sentimiento a los usuarios finales?\n\n\n**Justificaci\u00f3n:**\n\nEsta pregunta eval\u00faa la comprensi\u00f3n del estudiante sobre los principios de *Elasticidad* y *Respuesta R\u00e1pida* en el contexto del an\u00e1lisis de datos en tiempo real.  Se enfoca en la capacidad de escalar el sistema para manejar picos de demanda sin afectar el rendimiento.  Adem\u00e1s,  incita al estudiante a considerar diferentes tecnolog\u00edas de procesamiento de streams y a proponer estrategias para minimizar la latencia, un factor cr\u00edtico en los an\u00e1lisis en tiempo real.\n\n\n\n**En resumen,** estas dos preguntas obligan al estudiante a pensar cr\u00edticamente sobre los desaf\u00edos y soluciones para construir un sistema reactivo para el procesamiento de datos de redes sociales.  Abordan aspectos clave de la reactividad, incluyendo backpressure, resiliencia, elasticidad, y la importancia de la baja latencia en el contexto de an\u00e1lisis en tiempo real.  Adem\u00e1s, fomentan la consideraci\u00f3n de herramientas y tecnolog\u00edas relevantes para este tipo de sistemas.\n"}]}, "createdAt": "2025-05-22T10:25:30.207301", "expiration": "2025-05-29T15:25:30.149Z", "publicAccess": true}