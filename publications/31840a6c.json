{"id": "31840a6c", "examenData": {"email": "smartlabelperu@gmail.com", "examen_id": "155650", "nombre_examen": "Arquitecturas Reactivas", "tipo_examen": "Evaluaci\u00f3n", "fecha": "2025-06-25T21:49:31.130Z", "nombre_profesor": "Mariela Isabel Camargo Roman", "profesor_id": "16MI987", "preguntas_marcar": [{"numero": 1, "texto": "\u00bfQu\u00e9 patr\u00f3n de dise\u00f1o es crucial para la gesti\u00f3n de errores en un sistema reactivo?\nA) Singleton\nB) Factory\nC) Circuit Breaker\nD) Observer\nE) Strategy", "puntaje": 0.5, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 2}, {"numero": 2, "texto": "\u00bfQu\u00e9 tecnolog\u00eda es com\u00fanmente utilizada para la implementaci\u00f3n de flujos de datos reactivos?\nA) JDBC\nB) Spring MVC\nC) RxJava\nD) Hibernate\nE) JSF", "puntaje": 0.5, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 2}, {"numero": 3, "texto": "\u00bfCu\u00e1l es el beneficio principal de la elasticidad en una arquitectura reactiva?\nA) Mayor seguridad\nB) Menor latencia\nC) Adaptabilidad a la carga\nD) Simplificaci\u00f3n del c\u00f3digo\nE) Aumento de la complejidad", "puntaje": 0.5, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 4}, {"numero": 4, "texto": "\u00bfQu\u00e9 caracter\u00edstica describe mejor la resiliencia en un sistema reactivo?\nA) Capacidad de auto-reparaci\u00f3n\nB) Alta velocidad de procesamiento\nC) Uso eficiente de recursos\nD) Escalabilidad horizontal\nE) Simplicidad de implementaci\u00f3n", "puntaje": 0.5, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 3}, {"numero": 5, "texto": "\u00bfCu\u00e1l de las siguientes opciones describe mejor el concepto de \"backpressure\" en un sistema reactivo?\nA)  Manejo de errores\nB)  Control del flujo de datos\nC)  Escalamiento vertical\nD)  Optimizaci\u00f3n de la base de datos\nE)  Implementaci\u00f3n de microservicios", "puntaje": 0.5, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 4}, {"numero": 6, "texto": "\u00bfQu\u00e9 patr\u00f3n de dise\u00f1o se utiliza frecuentemente para manejar la concurrencia en sistemas reactivos?\nA) Singleton\nB) Factory\nC) Actor\nD) Observer\nE) Strategy", "puntaje": 0.5, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 1}, {"numero": 7, "texto": "\u00bfCu\u00e1l es la principal ventaja de usar un backpressure en un sistema reactivo?\nA) Mejora la latencia\nB) Reduce la complejidad\nC) Previene el colapso del sistema por sobrecarga\nD) Aumenta el rendimiento de escritura\nE) Simplifica la gesti\u00f3n de transacciones", "puntaje": 0.5, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 0}, {"numero": 8, "texto": "\u00bfQu\u00e9 tecnolog\u00eda es com\u00fanmente utilizada para implementar flujos de datos reactivos?\nA) JDBC\nB) Spring MVC\nC) RxJava\nD) Hibernate\nE) JPA", "puntaje": 0.5, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 1}, {"numero": 9, "texto": "\u00bfCu\u00e1l de las siguientes afirmaciones sobre la elasticidad en un sistema reactivo es FALSA?\nA) Permite escalar horizontalmente.\nB) Responde a las fluctuaciones de la carga.\nC) Requiere una infraestructura fija.\nD) Optimiza el uso de recursos.\nE) Mejora la disponibilidad.", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 0}, {"numero": 10, "texto": "\u00bfQu\u00e9 concepto describe la capacidad de un sistema reactivo para continuar operando a pesar de fallos?\nA) Elasticidad\nB) Responsividad\nC) Resiliencia\nD) Orientaci\u00f3n a mensajes\nE) Backpressure", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 3}], "preguntas_libres": [{"numero": 11, "texto": "En un entorno distribuido, explique c\u00f3mo las arquitecturas reactivas abordan la problem\u00e1tica de la falta de consistencia estricta en transacciones. Describa los mecanismos o patrones utilizados para garantizar la coherencia eventual y minimizar el impacto en la experiencia del usuario.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "Las arquitecturas reactivas en entornos distribuidos abordan la falta de consistencia estricta mediante la aceptaci\u00f3n de la *coherencia eventual*.  En lugar de bloquear transacciones hasta lograr consistencia inmediata, priorizan la disponibilidad y la tolerancia a fallos.  Utilizan patrones como CQRS (Command Query Responsibility Segregation) y Event Sourcing para desacoplar la escritura y lectura de datos.  Al persistir los cambios como una secuencia inmutable de eventos, se facilita la replicaci\u00f3n as\u00edncrona y la reconstrucci\u00f3n del estado.  Mecanismos como Sagas orquestan transacciones distribuidas compensables, revirtiendo operaciones previas en caso de fallo para mantener la consistencia eventual.  Para minimizar el impacto en la experiencia del usuario, se implementan estrategias como el optimismo compensatorio, mostrando la actualizaci\u00f3n inmediatamente y notificando posteriormente cualquier inconsistencia o realizando correcciones en segundo plano. La retroalimentaci\u00f3n al usuario es crucial para mantener la transparencia.\n"}, {"numero": 12, "texto": "Dise\u00f1e un esquema de arquitectura reactiva para un servicio de procesamiento de pagos en tiempo real. Justifique la selecci\u00f3n de componentes como actores (actors), buffers (buffers), o patrones de circuito (circuit breakers), y describa c\u00f3mo se coordinar\u00edan para manejar fallos en microservicios de terceros.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "Un sistema reactivo para procesar pagos en tiempo real puede basarse en actores para representar entidades como usuarios, comercios y bancos.  Cada actor gestiona su propio estado y se comunica con otros actores mediante mensajes as\u00edncronos.  Buffers, como colas de mensajes (ej. Kafka), desacoplan los actores y permiten el manejo de picos de carga.  Patrones de circuito (circuit breakers, ej. Hystrix) protegen el sistema de fallos en microservicios de terceros, como pasarelas de pago, cambiando a un estado abierto y devolviendo una respuesta predefinida si se detectan fallos repetidos.  La coordinaci\u00f3n se logra mediante el intercambio de mensajes entre actores.  Al recibir una solicitud de pago, el actor del usuario env\u00eda un mensaje al actor del comercio, que a su vez interact\u00faa con el microservicio de la pasarela de pago a trav\u00e9s de un circuit breaker.  Si la pasarela falla, el circuit breaker se abre, el actor del comercio recibe una notificaci\u00f3n y puede informar al usuario o intentar un m\u00e9todo de pago alternativo.  Este dise\u00f1o asegura la resiliencia y la capacidad de respuesta del sistema incluso ante fallos externos.\n"}, {"numero": 13, "texto": "Contrastando con arquitecturas tradicionales, \u00bfqu\u00e9 ventajas y desaf\u00edos introduces al adoptar un enfoque estrictamente orientado a mensajes (message-driven) en un sistema reactiva? Analice c\u00f3mo esto afecta la gesti\u00f3n de estados y la comunicaci\u00f3n entre componentes en escenarios cr\u00edticos.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "Las arquitecturas orientadas a mensajes (MOM) ofrecen ventajas significativas sobre las tradicionales en sistemas reactivos.  Facilitan el desacoplamiento, la escalabilidad y la resiliencia.  Al comunicar as\u00edncronamente a trav\u00e9s de mensajes, los componentes no necesitan conocerse directamente, permitiendo escalar y desplegar servicios independientemente.  Esta asincron\u00eda tambi\u00e9n mejora la tolerancia a fallos; si un componente falla, los mensajes se mantienen en cola hasta que est\u00e9 disponible, evitando la ca\u00edda del sistema.  \n\nSin embargo, MOM introduce desaf\u00edos. La gesti\u00f3n de estados se complejiza al no tener un estado compartido.  Cada componente gestiona su propio estado, requiriendo mecanismos de consistencia eventual.  La depuraci\u00f3n y el rastreo de mensajes tambi\u00e9n son m\u00e1s dif\u00edciles.  En escenarios cr\u00edticos, la garant\u00eda de entrega y el orden de los mensajes son cruciales, necesitando mecanismos robustos de manejo de errores y control de flujo.  La comunicaci\u00f3n s\u00edncrona, necesaria en algunos casos, se vuelve m\u00e1s compleja de implementar.\n"}, {"numero": 14, "texto": "\u00bfC\u00f3mo se puede integrar el concepto de \"elasticidad\" en una arquitectura reactiva para optimizar el uso de recursos en nubes din\u00e1micas (por ejemplo, Kubernetes o AWS Auto Scaling)? Explique los ajustes necesarios en el dise\u00f1o del sistema y las m\u00e9tricas que se deber\u00edan monitorear para activar esos mecanismos.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "La elasticidad en arquitecturas reactivas permite ajustar din\u00e1micamente los recursos seg\u00fan la demanda, optimizando el uso en nubes din\u00e1micas como Kubernetes o AWS Auto Scaling.  Se integra mediante mecanismos de escalado autom\u00e1tico basados en m\u00e9tricas clave.\n\nEl dise\u00f1o del sistema debe incorporar componentes desacoplados y escalables independientemente.  Se utilizan colas de mensajes para la comunicaci\u00f3n as\u00edncrona, balanceadores de carga para distribuir el tr\u00e1fico y bases de datos distribuidas para manejar la persistencia.  \n\nLas m\u00e9tricas cruciales a monitorear incluyen la latencia de las respuestas, el uso de CPU y memoria, la longitud de las colas y el n\u00famero de requests por segundo.  Estas m\u00e9tricas activan reglas de escalado predefinidas en la plataforma de orquestaci\u00f3n, aumentando o disminuyendo las instancias de los servicios seg\u00fan sea necesario. Esto asegura un rendimiento \u00f3ptimo bajo fluctuaciones de carga y minimiza el costo de recursos inactivos.  Por ejemplo,  si la latencia supera un umbral, se despliegan m\u00e1s instancias del servicio afectado.\n"}], "casos_uso": [{"numero": 15, "descripcion": "**Plataforma de monitoreo de sensores IoT para agricultura**  \n   - **Escenario**: Granjas inteligentes necesitan procesar flujos de datos de sensores (humedad, temperatura) en tiempo real para tomar decisiones inmediatas sobre riego.  \n   - **Requisitos**: Dise\u00f1ar una arquitectura reactiva que procese datos en streaming, aplique reglas de negocio y active alarmas si los valores superan umbrales cr\u00edticos.  \n   - **Herramientas**: Reactor (Project Reactor), MQTT para comunicaci\u00f3n con sensores, InfluxDB para series temporales, Grafana para visualizaci\u00f3n.", "pregunta": "Desarrolle una soluci\u00f3n para el caso descrito anteriormente", "puntaje": 5, "respuestaAlumno": "", "archivoSubido": false, "respuestaProfesor": "La arquitectura propuesta utiliza Reactor para procesar el flujo de datos de sensores IoT en tiempo real y tomar decisiones sobre el riego. Los sensores publican datos de temperatura y humedad a trav\u00e9s de MQTT. Un broker MQTT recibe estos mensajes y los reenv\u00eda a un servicio Reactor.\n\nEl servicio Reactor, implementado con Spring WebFlux, se suscribe al broker MQTT.  Utiliza `Flux` para representar el flujo continuo de datos.  Al recibir los datos, el flujo se procesa en varias etapas. Primero, se realiza una transformaci\u00f3n para convertir los mensajes MQTT en objetos Java representando las lecturas de los sensores. Luego, se aplica un filtro para descartar valores err\u00f3neos o fuera de rango.\n\nPosteriormente, el flujo se divide en dos ramas. La primera rama persiste los datos en InfluxDB, una base de datos optimizada para series temporales, utilizando el cliente de InfluxDB para Java.  Esto permite el almacenamiento hist\u00f3rico de las mediciones para an\u00e1lisis posteriores y visualizaci\u00f3n en Grafana.\n\nLa segunda rama aplica las reglas de negocio.  `Flux.filter()` eval\u00faa si los valores de temperatura o humedad superan los umbrales predefinidos. Si se detecta una anomal\u00eda, se genera una alarma.  Esta alarma puede ser una notificaci\u00f3n a trav\u00e9s de un servicio de mensajer\u00eda como Slack o un correo electr\u00f3nico al agricultor.  La l\u00f3gica de las reglas de negocio se implementa como predicados dentro del operador `filter`.\n\nLa visualizaci\u00f3n se realiza con Grafana, que se conecta a InfluxDB.  Grafana permite crear dashboards interactivos que muestran la evoluci\u00f3n de la temperatura y la humedad, facilitando la monitorizaci\u00f3n del estado del cultivo.  Adem\u00e1s, se pueden configurar alertas en Grafana basadas en umbrales, proporcionando una capa adicional de seguridad.\n\nEsta arquitectura reactiva, basada en Reactor y  MQTT, proporciona una soluci\u00f3n escalable y eficiente para el monitoreo en tiempo real de granjas inteligentes, permitiendo la toma de decisiones automatizada para el riego y la generaci\u00f3n de alertas tempranas ante condiciones cr\u00edticas.\n"}, {"numero": 16, "descripcion": "**Sistema de seguimiento de pedidos para e-commerce**  \n   - **Escenario**: Una tienda online quiere mostrar el estado de los pedidos en tiempo real (procesamiento, env\u00edo, entregado) a miles de usuarios simult\u00e1neamente.  \n   - **Requisitos**: Crear un backend reactivo que actualice estados y notifique a los clientes via push, minimizando latencia.  \n   - **Herramientas**: Spring WebFlux, Redis para cache, RabbitMQ para eventos, API Gateway (GraphQL).", "pregunta": "Desarrolle una soluci\u00f3n para el caso descrito anteriormente", "puntaje": 5, "respuestaAlumno": "", "archivoSubido": false, "respuestaProfesor": "Para implementar un sistema de seguimiento de pedidos en tiempo real con las herramientas especificadas, se propone la siguiente arquitectura reactiva:\n\n1. **Ingesti\u00f3n de eventos:**  Cuando un pedido cambia de estado (ej. de \"procesamiento\" a \"enviado\"), el microservicio responsable publica un evento en RabbitMQ.  Este evento contiene el ID del pedido y el nuevo estado.\n\n2. **Procesamiento de eventos:** Un consumidor Spring WebFlux suscrito a la cola de RabbitMQ recibe el evento.  Este consumidor actualiza el estado del pedido en la base de datos y en la cach\u00e9 Redis para un acceso r\u00e1pido.\n\n3. **Notificaciones push:**  El consumidor, tras actualizar el estado, publica un nuevo evento en un topic de RabbitMQ dedicado a notificaciones.  Un servicio separado, tambi\u00e9n reactivo, consume estos eventos y env\u00eda notificaciones push a los usuarios suscritos al pedido v\u00eda websocket, utilizando el API Gateway (GraphQL) como intermediario.  GraphQL permite a los clientes suscribirse a actualizaciones espec\u00edficas de pedidos.\n\n4. **API Gateway (GraphQL):**  Expone una API GraphQL que permite a los clientes consultar el estado de un pedido en tiempo real desde la cach\u00e9 Redis.  Adem\u00e1s, gestiona las suscripciones websocket para las notificaciones push.  Utiliza un modelo de suscripci\u00f3n para que los clientes reciban actualizaciones solo cuando el estado del pedido cambia.\n\n5. **Cache Redis:** Almacena el estado actual de los pedidos para un acceso de baja latencia.  Esto minimiza la carga en la base de datos y permite escalar la lectura de estados a miles de usuarios simult\u00e1neamente.\n\n6. **Escalabilidad:**  Spring WebFlux, RabbitMQ y Redis son tecnolog\u00edas inherentemente escalables, permitiendo manejar un gran volumen de pedidos y notificaciones.  Se pueden desplegar m\u00faltiples instancias de los microservicios y consumidores para distribuir la carga.\n\nEsta arquitectura reactiva asegura actualizaciones en tiempo real, minimiza la latencia y permite escalar para manejar miles de usuarios concurrentes.  La combinaci\u00f3n de Spring WebFlux, RabbitMQ, Redis y API Gateway (GraphQL) proporciona una soluci\u00f3n robusta y eficiente para el seguimiento de pedidos en e-commerce.\n"}]}, "createdAt": "2025-06-25T16:49:31.198239", "expiration": "2025-07-02T21:49:31.130Z", "publicAccess": true}