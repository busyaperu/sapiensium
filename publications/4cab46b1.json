{"id": "4cab46b1", "examenData": {"examen_id": "212635", "nombre_examen": "Arquitecturas Reactivas", "tipo_examen": "Evaluaci\u00f3n", "fecha": "2025-06-01T21:42:32.099Z", "nombre_profesor": "Mariela Isabel Camargo Rom\u00e1n", "profesor_id": "16MI987", "preguntas_marcar": [], "preguntas_libres": [{"numero": 1, "texto": "Explique c\u00f3mo el patr\u00f3n de dise\u00f1o \"Command Query Responsibility Segregation\" (CQRS) se integra con una arquitectura reactiva, detallando su impacto en la performance y la consistencia de datos.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "CQRS mejora las arquitecturas reactivas al separar las operaciones de lectura (Queries) de las de escritura (Commands).  Esta segregaci\u00f3n permite escalar cada parte independientemente seg\u00fan sus necesidades. Las consultas, a menudo m\u00e1s frecuentes, pueden optimizarse para la lectura, utilizando cach\u00e9s y r\u00e9plicas, incrementando la performance. Los comandos, por otro lado, se gestionan como una secuencia de eventos inmutables, facilitando la concurrencia y la auditabilidad.\n\nEsta separaci\u00f3n, sin embargo, introduce la complejidad de la consistencia eventual.  Mientras que las lecturas ofrecen una vista consistente del pasado, las actualizaciones no se reflejan instant\u00e1neamente.  Se utilizan mecanismos como Event Sourcing para propagar los cambios y lograr la consistencia eventual.  Esto implica un trade-off: mayor performance y escalabilidad a cambio de una consistencia relajada, aceptable en muchos sistemas reactivos que priorizan la disponibilidad y la tolerancia a fallos.  En resumen, CQRS facilita la construcci\u00f3n de sistemas reactivos m\u00e1s escalables y performantes, gestionando la consistencia eventual de forma expl\u00edcita.\n", "archivoId": "anexo_284879_1748470036329", "archivoNombre": "Diagrama sin t\u00edtulo.drawio.pdf", "archivoUrl": "https://cloud.appwrite.io/v1/storage/buckets/APPWRITE_BUCKET_DOCUMENTO_ANEXO_EXAMEN/files/anexo_284879_1748470036329/view?project=67e565df00172171560", "archivoTama\u00f1o": 2352, "archivoTipo": "application/pdf"}, {"numero": 2, "texto": "Analice la implementaci\u00f3n de un sistema de backpressure en una arquitectura reactiva, explicando diferentes estrategias para manejar la sobrecarga y c\u00f3mo estas estrategias impactan en la resiliencia del sistema.  Incluya ejemplos concretos.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "Un sistema reactivo bajo presi\u00f3n puede implementar backpressure para evitar la sobrecarga.  Este mecanismo permite al consumidor controlar el flujo de datos del productor, previniendo desbordamientos.  Existen diversas estrategias para manejar la sobrecarga: control de flujo basado en buffer, donde el productor se bloquea si el buffer del consumidor est\u00e1 lleno;  ventanas de tiempo, limitando la cantidad de datos en un periodo; y dropping messages, descartando mensajes menos cr\u00edticos cuando la capacidad se excede.  Por ejemplo, en un sistema de procesamiento de streams, si el consumidor se ve saturado procesando datos, puede aplicar backpressure.  Con un buffer limitado, el productor pausar\u00eda el env\u00edo hasta que el consumidor procese los datos existentes.  Usando ventanas de tiempo, el consumidor podr\u00eda solicitar solo un n\u00famero fijo de mensajes por segundo. Finalmente, descartando mensajes, se priorizar\u00edan mensajes cr\u00edticos, como alertas del sistema, sobre datos menos relevantes, garantizando la resiliencia del sistema bajo alta carga. La elecci\u00f3n de la estrategia depende de los requisitos de la aplicaci\u00f3n y la tolerancia a la p\u00e9rdida de datos.\n", "archivoId": "anexo_284879_1748469930521", "archivoNombre": "Documentos-de-embarque.pdf", "archivoUrl": "https://cloud.appwrite.io/v1/storage/buckets/APPWRITE_BUCKET_DOCUMENTO_ANEXO_EXAMEN/files/anexo_284879_1748469930521/view?project=67e565df00172171560", "archivoTama\u00f1o": 168651, "archivoTipo": "application/pdf"}, {"numero": 3, "texto": "Compare y contraste dos frameworks o librer\u00edas diferentes para el desarrollo de aplicaciones reactivas (ej. Spring WebFlux y Akka Streams).  Enf\u00f3quese en sus modelos de programaci\u00f3n, sus fortalezas y debilidades en diferentes escenarios.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "Spring WebFlux y Akka Streams son frameworks para construir aplicaciones reactivas, pero difieren en sus modelos de programaci\u00f3n. WebFlux, basado en el patr\u00f3n Reactor, utiliza un enfoque declarativo con operadores funcionales para componer flujos de datos as\u00edncronos.  Akka Streams, por otro lado, se basa en el modelo Actor y ofrece un mayor control sobre el grafo de flujo de datos, permitiendo una gesti\u00f3n m\u00e1s granular del paralelismo y la retropresi\u00f3n.\n\nWebFlux, al integrarse f\u00e1cilmente con el ecosistema Spring, simplifica el desarrollo de aplicaciones web reactivas. Es ideal para escenarios con alta concurrencia y I/O intensiva, como APIs REST. Sin embargo, su modelo puede ser menos flexible que Akka Streams para escenarios complejos de procesamiento de flujos.\n\nAkka Streams, con su modelo m\u00e1s flexible, brilla en escenarios que requieren un control preciso sobre el flujo de datos, como procesamiento de eventos en tiempo real o sistemas distribuidos.  No obstante, su curva de aprendizaje es m\u00e1s pronunciada y requiere una mayor comprensi\u00f3n del modelo Actor.  La elecci\u00f3n entre ambos depende de las necesidades espec\u00edficas del proyecto.\n", "archivoId": "anexo_284879_1748470036329", "archivoNombre": "", "archivoUrl": "", "archivoTama\u00f1o": 2352, "archivoTipo": "application/pdf"}, {"numero": 4, "texto": "Dise\u00f1e una arquitectura reactiva para una aplicaci\u00f3n de streaming de video en tiempo real, considerando aspectos como la gesti\u00f3n de la conexi\u00f3n con los usuarios, el manejo de errores y la escalabilidad horizontal.  Justifique sus decisiones de dise\u00f1o.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "Una arquitectura reactiva para streaming de video debe ser resiliente y escalable.  Utilizar\u00eda un dise\u00f1o basado en microservicios con los siguientes componentes: un servicio de gesti\u00f3n de conexiones (ej. WebSockets) para comunicaci\u00f3n bidireccional con los clientes, un servicio de streaming encargado de la distribuci\u00f3n del video, y un servicio de gesti\u00f3n de usuarios para autenticaci\u00f3n y autorizaci\u00f3n.  Para la escalabilidad, emplear\u00eda balanceo de carga delante de cada servicio y orquestaci\u00f3n de contenedores (ej. Kubernetes) para desplegar y escalar los microservicios horizontalmente seg\u00fan la demanda.  La gesti\u00f3n de errores se implementar\u00eda mediante reintentos, mecanismos de fallback y circuit breakers para evitar la cascada de fallos.  El almacenamiento del video se realizar\u00eda en un sistema distribuido como un object storage (ej. S3).  Esta arquitectura permite un streaming fluido, tolerante a fallos y adaptable a picos de usuarios, cruciales para una buena experiencia de usuario.  La elecci\u00f3n de WebSockets permite una comunicaci\u00f3n en tiempo real eficiente y la arquitectura de microservicios facilita el mantenimiento y la escalabilidad independiente de cada componente.\n"}], "casos_uso": []}, "createdAt": "2025-06-01T16:42:32.150394", "expiration": "2025-06-08T21:42:32.099Z", "publicAccess": true}