{"id": "95d3d192", "examenData": {"examen_id": "477032", "nombre_examen": "Arquitecturas Reactivas", "tipo_examen": "Evaluaci\u00f3n", "fecha": "2025-05-22T01:41:09.527Z", "nombre_profesor": "Mariela Isabel Camargo Rom\u00e1n", "profesor_id": "16MI987", "preguntas_marcar": [{"numero": 1, "texto": "\u00bfQu\u00e9 patr\u00f3n de dise\u00f1o se utiliza a menudo para manejar la concurrencia en sistemas reactivos?\nA) Singleton\nB) Factory\nC) Actor\nD) Observer\nE) Command", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 1}, {"numero": 2, "texto": "\u00bfCu\u00e1l es la principal ventaja del uso de backpressure en un sistema reactivo?\nA) Mayor rendimiento\nB) Menor latencia\nC) Prevenci\u00f3n de sobrecarga del sistema\nD) Aumento de la concurrencia\nE) Simplificaci\u00f3n del c\u00f3digo", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 2}], "preguntas_libres": [{"numero": 3, "texto": "Explique c\u00f3mo la programaci\u00f3n reactiva aborda el problema de la gesti\u00f3n de errores en un sistema distribuido, considerando la propagaci\u00f3n de fallos y la recuperaci\u00f3n de la aplicaci\u00f3n.  Proporcione ejemplos concretos.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "## Gesti\u00f3n de Errores en Sistemas Distribuidos con Programaci\u00f3n Reactiva\n\nLa programaci\u00f3n reactiva ofrece un enfoque elegante y robusto para la gesti\u00f3n de errores en sistemas distribuidos, simplificando el manejo de la propagaci\u00f3n de fallos y facilitando la recuperaci\u00f3n de la aplicaci\u00f3n.  En lugar de depender de mecanismos tradicionales como `try-catch` dispersos por el c\u00f3digo, la programaci\u00f3n reactiva utiliza flujos de datos as\u00edncronos y operadores espec\u00edficos para encapsular y gestionar los errores de forma declarativa. Esto proporciona una mayor claridad, facilita el razonamiento sobre el comportamiento del sistema en situaciones de fallo y promueve la resiliencia.\n\n**Propagaci\u00f3n de Fallos:**\n\nEn un sistema distribuido, un fallo en un componente puede propagarse r\u00e1pidamente a otros, causando un efecto cascada.  La programaci\u00f3n reactiva aborda esto mediante:\n\n* **Encapsulaci\u00f3n de Errores en el Flujo de Datos:** Los errores se representan como eventos dentro del flujo de datos reactivo, en lugar de excepciones que interrumpen el flujo de ejecuci\u00f3n.  Esto permite que el sistema contin\u00fae procesando otros eventos, incluso en presencia de fallos.\n\n* **Operadores de Gesti\u00f3n de Errores:**  Bibliotecas reactivas como RxJava o Reactor ofrecen operadores espec\u00edficos para manejar errores, como:\n    * `onErrorReturn`:  Retorna un valor por defecto en caso de error.\n    * `onErrorResume`:  Sustituye el flujo de datos original por otro en caso de error, permitiendo una l\u00f3gica de fallback.\n    * `retry`:  Reintenta la operaci\u00f3n un n\u00famero determinado de veces en caso de error.\n    * `retryWhen`:  Permite una l\u00f3gica de reintento m\u00e1s sofisticada, controlando el tiempo entre reintentos y el tipo de errores que se reintentan.\n\n**Recuperaci\u00f3n de la Aplicaci\u00f3n:**\n\nLa programaci\u00f3n reactiva facilita la recuperaci\u00f3n de la aplicaci\u00f3n tras un fallo mediante:\n\n* **Aislamiento de Fallos:** La encapsulaci\u00f3n de errores en el flujo de datos limita el impacto de un fallo a una parte espec\u00edfica del sistema, evitando que se propague a otros componentes.\n\n* **Fallback y Degradaci\u00f3n Graciosa:** Los operadores como `onErrorResume` permiten implementar estrategias de fallback, ofreciendo una funcionalidad alternativa o degradada en caso de fallo de un servicio.  Esto mejora la experiencia del usuario y mantiene la disponibilidad del sistema.\n\n* **Supervisi\u00f3n y Observabilidad:**  La naturaleza reactiva del sistema facilita la supervisi\u00f3n del estado de los componentes y la detecci\u00f3n de fallos.  Los flujos de datos pueden ser observados para identificar patrones de error y tomar medidas correctivas.\n\n**Ejemplos Concretos:**\n\n1. **Servicio de Recomendaciones:** Imaginemos un servicio que obtiene recomendaciones de productos de m\u00faltiples microservicios.  Si uno de estos microservicios falla, en lugar de que toda la aplicaci\u00f3n falle, podemos usar `onErrorResume` para obtener recomendaciones de un servicio de fallback o mostrar un conjunto de recomendaciones por defecto.\n\n```java\n// Usando Reactor\nMono<List<Recommendation>> recommendations = \n    recommendationsService.getRecommendations()\n        .onErrorResume(error -> fallbackRecommendationsService.getRecommendations());\n```\n\n2. **Retrying una Operaci\u00f3n de Red:** Si una llamada a una API externa falla debido a un problema de red temporal, podemos usar `retryWhen` para reintentar la operaci\u00f3n con un retardo exponencial.\n\n```java\n// Usando RxJava\nObservable<Data> data = api.getData()\n    .retryWhen(errors -> errors\n        .flatMap(error -> {\n            if (error instanceof NetworkException) {\n                return Flowable.timer(retryDelay, TimeUnit.MILLISECONDS);\n            } else {\n                return Flowable.error(error);\n            }\n        }));\n```\n\n**Conclusi\u00f3n:**\n\nLa programaci\u00f3n reactiva proporciona un conjunto de herramientas poderosas para gestionar errores en sistemas distribuidos. La encapsulaci\u00f3n de errores, los operadores espec\u00edficos y la naturaleza as\u00edncrona de los flujos de datos facilitan la propagaci\u00f3n controlada de fallos, la implementaci\u00f3n de estrategias de recuperaci\u00f3n y la construcci\u00f3n de aplicaciones m\u00e1s resilientes y tolerantes a fallos.  Al adoptar un enfoque declarativo para la gesti\u00f3n de errores, los desarrolladores pueden escribir c\u00f3digo m\u00e1s limpio, comprensible y f\u00e1cil de mantener, lo que en \u00faltima instancia conduce a sistemas m\u00e1s robustos y fiables.\n"}], "casos_uso": [{"numero": 4, "descripcion": "Use Case 1 (Ingesti\u00f3n y Distribuci\u00f3n de Video): Describe c\u00f3mo una arquitectura reactiva puede manejar la alta tasa de datos de m\u00faltiples fuentes de video entrantes y distribuirlas eficientemente a los servicios de transcodificaci\u00f3n y a los usuarios finales, asegurando que el sistema permanezca receptivo incluso bajo carga extrema. Prop\u00f3n un patr\u00f3n de comunicaci\u00f3n as\u00edncrona adecuado.", "pregunta": "Desarrolle una soluci\u00f3n para el caso descrito anteriormente", "puntaje": 1, "respuestaAlumno": "", "archivoSubido": false, "respuestaProfesor": "## Soluci\u00f3n para el Caso de Ingesti\u00f3n y Distribuci\u00f3n de Video con Arquitectura Reactiva\n\nEste caso requiere una arquitectura reactiva capaz de manejar un alto volumen de datos de video desde m\u00faltiples fuentes, distribuirlos eficientemente a servicios de transcodificaci\u00f3n y a usuarios finales, y mantener la responsividad bajo carga extrema.  A continuaci\u00f3n, se propone una soluci\u00f3n utilizando un patr\u00f3n de comunicaci\u00f3n as\u00edncrona basado en un **bus de mensajes (Message Broker)**.\n\n**Arquitectura:**\n\nLa arquitectura se compone de los siguientes componentes:\n\n1. **Ingesta de Video (Video Ingestion):**  M\u00faltiples instancias de este componente reciben flujos de video de diversas fuentes.  Cada instancia es responsable de recibir, segmentar el video en chunks y publicar metadatos y la ubicaci\u00f3n de estos chunks en el bus de mensajes.  No realizan transcodificaci\u00f3n, lo que les permite mantenerse ligeros y receptivos.\n\n2. **Bus de Mensajes (Message Broker - ej. Kafka, RabbitMQ):** Act\u00faa como el backbone de la arquitectura, desacoplando productores (Ingesta de Video) y consumidores (Transcodificaci\u00f3n, Distribuci\u00f3n).  Proporciona durabilidad, escalabilidad y tolerancia a fallos. Se utilizar\u00e1n diferentes topics para la gesti\u00f3n de mensajes: uno para nuevos videos, otro para notificaciones de transcodificaci\u00f3n completada, etc.\n\n3. **Servicio de Transcodificaci\u00f3n (Transcoding Service):**  M\u00faltiples instancias de este servicio se suscriben al topic de nuevos videos.  Consumen mensajes, descargan los chunks de video desde su ubicaci\u00f3n, realizan la transcodificaci\u00f3n a diferentes formatos (ej. 480p, 720p, 1080p) y publican un mensaje en el topic de transcodificaci\u00f3n completada, incluyendo la ubicaci\u00f3n de los videos transcodificados.  La escalabilidad horizontal de este servicio es crucial para manejar picos de demanda.\n\n4. **Servicio de Distribuci\u00f3n (Distribution Service):** Este servicio se suscribe al topic de transcodificaci\u00f3n completada.  Recibe notificaciones de videos transcodificados, actualiza la base de datos con la informaci\u00f3n de los diferentes formatos disponibles y se encarga de servir el video a los usuarios finales a trav\u00e9s de un CDN o un sistema de streaming.\n\n5. **Base de Datos (Database):** Almacena metadatos de los videos, incluyendo informaci\u00f3n sobre las diferentes transcodificaciones disponibles y su ubicaci\u00f3n.\n\n**Patr\u00f3n de Comunicaci\u00f3n As\u00edncrona:**\n\nEl patr\u00f3n utilizado es **publish-subscribe** a trav\u00e9s del bus de mensajes.  Esto permite:\n\n* **Desacoplamiento:**  Los componentes no necesitan conocerse entre s\u00ed, solo interact\u00faan a trav\u00e9s del bus de mensajes.\n* **Escalabilidad:**  Cada componente puede escalar independientemente seg\u00fan la demanda.\n* **Resiliencia:**  Si un componente falla, los dem\u00e1s contin\u00faan funcionando.  El bus de mensajes garantiza la entrega de los mensajes una vez que el componente se recupera.\n* **Backpressure:**  Mecanismos de backpressure en el bus de mensajes pueden ayudar a gestionar la carga en los consumidores, evitando que se saturen.\n\n**Flujo de Trabajo:**\n\n1. Un nuevo flujo de video llega al componente de Ingesta de Video.\n2. La Ingesta de Video segmenta el video, guarda los chunks y publica un mensaje en el topic de \"nuevos videos\" con la ubicaci\u00f3n de los chunks y metadatos.\n3. El Servicio de Transcodificaci\u00f3n consume el mensaje, descarga los chunks, realiza la transcodificaci\u00f3n y publica un mensaje en el topic de \"transcodificaci\u00f3n completada\".\n4. El Servicio de Distribuci\u00f3n consume el mensaje de \"transcodificaci\u00f3n completada\", actualiza la base de datos y pone el video a disposici\u00f3n de los usuarios finales.\n\n**Beneficios de la Arquitectura Reactiva:**\n\n* **Alta Responsividad:**  El sistema permanece receptivo incluso bajo alta carga gracias al desacoplamiento y la asincron\u00eda.\n* **Escalabilidad:**  Cada componente puede escalar independientemente para manejar picos de demanda.\n* **Resiliencia:**  El sistema es tolerante a fallos gracias al desacoplamiento y la durabilidad del bus de mensajes.\n* **Eficiencia:**  La transcodificaci\u00f3n se realiza en segundo plano, permitiendo una entrega r\u00e1pida del video original a los usuarios mientras se generan diferentes formatos.\n\n**Consideraciones Adicionales:**\n\n* **Monitorizaci\u00f3n:**  Es crucial monitorizar el rendimiento de cada componente y el bus de mensajes para detectar cuellos de botella y asegurar un funcionamiento \u00f3ptimo.\n* **Seguridad:**  Se deben implementar medidas de seguridad para proteger los flujos de video y el acceso a los diferentes componentes.\n* **Almacenamiento:**  Se debe considerar una estrategia de almacenamiento eficiente y escalable para los chunks de video y las diferentes transcodificaciones.\n\n\nEsta soluci\u00f3n proporciona una arquitectura robusta y escalable para la ingesti\u00f3n y distribuci\u00f3n de video, utilizando principios reactivos y un patr\u00f3n de comunicaci\u00f3n as\u00edncrona para manejar altas tasas de datos y mantener la responsividad bajo carga extrema.\n"}]}, "createdAt": "2025-05-21T20:41:09.561273", "expiration": "2025-05-29T01:41:09.527Z", "publicAccess": true}