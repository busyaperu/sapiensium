{"id": "c4276fb6", "examenData": {"examen_id": "691763", "nombre_examen": "Programaci\u00f3n UML", "tipo_examen": "Evaluaci\u00f3n", "fecha": "2025-04-30T19:57:28.225Z", "nombre_profesor": "Mariela Isabel Camargo Rom\u00e1n", "profesor_id": "16MI987", "preguntas_marcar": [{"numero": 1, "texto": "\u00bfQu\u00e9 patr\u00f3n de dise\u00f1o es com\u00fan en sistemas reactivos para manejar flujos de datos as\u00edncronos?  \nA) Singleton  \nB) Observer  \nC) Decorator  \nD) Factory  \nE) Proxy", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 4}, {"numero": 2, "texto": "\u00bfQu\u00e9 tecnolog\u00eda se utiliza com\u00fanmente para implementar sistemas reactivos en Java?  \nA) Spring MVC  \nB) Hibernate  \nC) Reactor  \nD) JDBC  \nE) JSP", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 3}, {"numero": 3, "texto": "\u00bfCu\u00e1l de las siguientes caracter\u00edsticas NO es parte del Manifiesto Reactivo?  \nA) Responsivo  \nB) Escalable  \nC) Monol\u00edtico  \nD) Resiliente  \nE) Orientado a mensajes", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 2}, {"numero": 4, "texto": "\u00bfQu\u00e9 tipo de comunicaci\u00f3n se promueve en las arquitecturas reactivas?  \nA) S\u00edncrona  \nB) Bloqueante  \nC) As\u00edncrona  \nD) Directa  \nE) Basada en sesiones", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 0}, {"numero": 5, "texto": "\u00bfQu\u00e9 componente es esencial en un sistema reactivo para manejar la concurrencia?  \nA) Hilos tradicionales  \nB) Event loops  \nC) Variables globales  \nD) Locks expl\u00edcitos  \nE) Transacciones largas", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 2}], "preguntas_libres": [{"numero": 6, "texto": "**Intermedio:** Compara y contrasta el uso de *Event Sourcing* con *CQRS* en una arquitectura reactiva, detallando los beneficios y desaf\u00edos de cada enfoque en un escenario de alta concurrencia.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "## Comparaci\u00f3n y Contraste de Event Sourcing y CQRS en Arquitecturas Reactivas bajo Alta Concurrencia\n\nEvent Sourcing (ES) y Command Query Responsibility Segregation (CQRS) son patrones arquitect\u00f3nicos que a menudo se usan juntos, especialmente en sistemas reactivos que manejan alta concurrencia. Sin embargo, son conceptos distintos con beneficios y desaf\u00edos espec\u00edficos.  Aunque complementarios, no son mutuamente dependientes.\n\n**Event Sourcing (ES)**\n\n* **Concepto:** ES persiste el estado de una entidad como una secuencia inmutable de eventos, en lugar de guardar solo el \u00faltimo estado. Cada evento representa un cambio en el estado de la entidad. Para reconstruir el estado actual, se reproducen todos los eventos desde el inicio.\n\n* **Beneficios en alta concurrencia:**\n    * **Optimiza la escritura:** Las escrituras se convierten en simples ap\u00e9ndices al log de eventos, eliminando bloqueos y mejorando el rendimiento, especialmente bajo alta concurrencia.  No hay conflictos de escritura tradicionales.\n    * **Auditoria e historial completo:**  Proporciona un registro auditable de todos los cambios, facilitando la depuraci\u00f3n, el an\u00e1lisis de datos y la reversi\u00f3n a estados anteriores.\n    * **Escalabilidad horizontal:** El log de eventos puede ser f\u00e1cilmente particionado y distribuido para una mejor escalabilidad.\n    * **Arquitectura orientada a eventos:** Facilita la integraci\u00f3n con otros sistemas a trav\u00e9s de la publicaci\u00f3n de eventos.\n\n* **Desaf\u00edos en alta concurrencia:**\n    * **Complejidad de lectura:** Reconstruir el estado actual puede ser costoso, especialmente para entidades con un largo historial de eventos.  Se requieren estrategias de optimizaci\u00f3n como snapshots.\n    * **Versionamiento de eventos:**  La evoluci\u00f3n del esquema de eventos puede ser compleja, requiriendo mecanismos de migraci\u00f3n para mantener la compatibilidad.\n    * **Dependencia del orden de eventos:**  El orden de los eventos es crucial para la consistencia del estado.  Gestionar la concurrencia en la escritura de eventos puede ser complejo.\n\n\n**CQRS (Command Query Responsibility Segregation)**\n\n* **Concepto:** CQRS separa las operaciones de lectura (Queries) de las operaciones de escritura (Commands). Esto permite optimizar cada ruta de acceso de forma independiente.\n\n* **Beneficios en alta concurrencia:**\n    * **Escalabilidad independiente:**  Permite escalar las lecturas y escrituras de forma independiente, adapt\u00e1ndose a diferentes patrones de carga.  Se pueden usar diferentes modelos de datos para lectura y escritura.\n    * **Rendimiento optimizado:**  Se pueden utilizar bases de datos especializadas y cach\u00e9s para optimizar tanto las lecturas como las escrituras.\n    * **Simplicidad:**  Simplifica el dise\u00f1o y la implementaci\u00f3n de cada operaci\u00f3n, al separar las responsabilidades.\n\n* **Desaf\u00edos en alta concurrencia:**\n    * **Consistencia eventual:**  La separaci\u00f3n de modelos de datos puede llevar a una consistencia eventual entre lecturas y escrituras. Se necesitan estrategias para manejar esta eventual consistencia.\n    * **Complejidad a\u00f1adida:**  CQRS introduce una capa adicional de complejidad en la arquitectura.\n\n\n**ES y CQRS Juntos**\n\nES y CQRS se complementan bien.  ES proporciona un flujo natural de eventos que CQRS puede utilizar para actualizar los modelos de lectura.  Los comandos pueden generar eventos que se persisten en el log de eventos (ES) y luego se utilizan para actualizar las vistas de lectura (CQRS).\n\n**Ejemplo en un escenario de alta concurrencia:**\n\nImagine una plataforma de comercio electr\u00f3nico con un alto volumen de pedidos.  Usando ES, cada pedido se representar\u00eda como una secuencia de eventos (e.g., `PedidoCreado`, `ProductoAgregado`, `Direcci\u00f3nEnviada`, `PagoRealizado`).  CQRS permitir\u00eda escalar las consultas de estado del pedido independientemente del procesamiento de nuevos pedidos.  Las vistas de lectura podr\u00edan ser optimizadas para consultas espec\u00edficas, como \"pedidos por cliente\" o \"pedidos por fecha\".\n\n**Conclusi\u00f3n:**\n\nTanto ES como CQRS ofrecen beneficios significativos en escenarios de alta concurrencia, particularmente en arquitecturas reactivas. Sin embargo, tambi\u00e9n presentan desaf\u00edos que deben ser considerados cuidadosamente.  La decisi\u00f3n de usar ES, CQRS, o ambos, depende de los requisitos espec\u00edficos del sistema y la complejidad que se est\u00e9 dispuesto a asumir.  Usados correctamente, pueden mejorar significativamente la escalabilidad, el rendimiento y la mantenibilidad de una aplicaci\u00f3n.\n"}, {"numero": 7, "texto": "**Avanzado:** Analiza c\u00f3mo el *Backpressure* se maneja en sistemas reactivos y prop\u00f3n una estrategia para implementarlo en un flujo de datos en tiempo real con picos de carga impredecibles.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "## Respuesta Modelo: Manejo de Backpressure en Sistemas Reactivos\n\nEl *backpressure* es un mecanismo crucial en los sistemas reactivos que permite a un consumidor controlar el flujo de datos proveniente de un productor cuando el consumidor no puede procesar los datos a la misma velocidad que los recibe.  Sin un manejo adecuado, el *backpressure* puede llevar a la sobrecarga del sistema, p\u00e9rdida de datos y fallos.  En sistemas con picos de carga impredecibles, un manejo robusto del *backpressure* es a\u00fan m\u00e1s cr\u00edtico.\n\n**Mecanismos de Backpressure en Sistemas Reactivos:**\n\nLos sistemas reactivos, basados en el Manifiesto Reactivo, suelen manejar el *backpressure* a trav\u00e9s de diferentes estrategias:\n\n1. **Push-based con control de flujo:**  En este modelo, el productor \"empuja\" datos al consumidor.  El control de flujo se implementa para regular la velocidad de env\u00edo. Algunos ejemplos incluyen:\n\n    * **Buffering:** El consumidor utiliza un buffer para almacenar temporalmente los datos recibidos.  Sin embargo, con picos de carga, el buffer puede desbordarse.\n    * **Throttling:** El consumidor solicita al productor que reduzca la velocidad de env\u00edo.  Esto requiere comunicaci\u00f3n bidireccional entre productor y consumidor.\n    * **Windowing:** Se procesan los datos en ventanas de tiempo o tama\u00f1o, permitiendo al consumidor gestionar la carga en bloques.\n\n2. **Pull-based:**  El consumidor \"tira\" de los datos del productor a su propio ritmo. Este modelo es inherentemente resistente al *backpressure* ya que el productor solo env\u00eda datos cuando el consumidor los solicita.  Ejemplos incluyen:\n\n    * **Iteradores:** El consumidor solicita el siguiente elemento al productor cuando est\u00e1 listo.\n    * **Suscripciones a demanda:** El consumidor se suscribe a un flujo de datos y solicita expl\u00edcitamente los datos cuando los necesita.\n\n\n**Estrategia para Picos de Carga Impredecibles:**\n\nPara un flujo de datos en tiempo real con picos de carga impredecibles, una estrategia efectiva combina elementos de *push* y *pull* con mecanismos de control de flujo din\u00e1mico:\n\n1. **Reactive Streams:**  Utilizar una implementaci\u00f3n de Reactive Streams (como RxJava, Project Reactor, o Akka Streams) proporciona una base s\u00f3lida para el manejo de *backpressure*.  Estas bibliotecas ofrecen operadores espec\u00edficos para control de flujo.\n\n2. **Buffering adaptativo:**  Implementar un buffer con tama\u00f1o din\u00e1mico que se ajuste a la carga actual.  Monitorizar el nivel de llenado del buffer y ajustar su capacidad seg\u00fan sea necesario.  Esto ayuda a absorber picos de carga moment\u00e1neos.\n\n3. **Throttling din\u00e1mico:**  Utilizar un mecanismo de *throttling* que ajuste la velocidad de producci\u00f3n en funci\u00f3n de la capacidad del consumidor.  Esto requiere una comunicaci\u00f3n bidireccional eficiente entre productor y consumidor.\n\n4. **Degradaci\u00f3n elegante:**  En casos de sobrecarga extrema, implementar mecanismos de degradaci\u00f3n elegante, como descartar datos menos importantes o reducir la calidad del servicio.  Priorizar la estabilidad del sistema sobre el procesamiento completo de datos durante picos de carga.\n\n5. **Monitorizaci\u00f3n y alertas:**  Implementar un sistema de monitorizaci\u00f3n que rastree m\u00e9tricas clave como el nivel de llenado del buffer, la tasa de producci\u00f3n y la tasa de consumo.  Configurar alertas para notificar a los administradores del sistema sobre posibles problemas de *backpressure*.\n\n\n**Ejemplo conceptual (pseudo-c\u00f3digo):**\n\n```java\n// Productor (ej. sensor de datos)\nFlux<Data> dataStream = Flux.generate(...); // Flujo de datos\n\n// Consumidor (ej. procesador de datos)\ndataStream\n  .onBackpressureBuffer(bufferSize, data -> log.warn(\"Buffer lleno, descartando dato: \" + data), BufferOverflowStrategy.DROP_OLDEST)\n  .onBackpressureLatest() // Solo procesar el dato m\u00e1s reciente\n  .limitRate(rateLimiter.getRate()) // Control de flujo din\u00e1mico\n  .subscribe(data -> processData(data));\n```\n\n\n**Conclusi\u00f3n:**\n\nEl manejo efectivo del *backpressure* es fundamental para la estabilidad y el rendimiento de los sistemas reactivos, especialmente en escenarios con picos de carga impredecibles.  Combinar estrategias de *push* y *pull* con control de flujo din\u00e1mico, buffering adaptativo y degradaci\u00f3n elegante permite construir sistemas robustos y resilientes.  La monitorizaci\u00f3n continua y las alertas son esenciales para detectar y mitigar problemas de *backpressure* antes de que afecten la operaci\u00f3n del sistema.\n"}, {"numero": 8, "texto": "**Intermedio:** Explica c\u00f3mo las arquitecturas reactivas abordan el problema de la latencia en sistemas distribuidos, mencionando patrones como *Circuit Breaker* o *Bulkheading* con ejemplos concretos.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "## Respuesta Modelo: Arquitecturas Reactivas y la Latencia en Sistemas Distribuidos\n\nLas arquitecturas reactivas buscan construir sistemas distribuidos resilientes y responsivos, minimizando el impacto de la latencia inherente a estos entornos.  Lo logran mediante la aplicaci\u00f3n de principios como la **responsividad**, la **elasticidad**, la **resiliencia** y la **orientaci\u00f3n a mensajes**.  Estos principios se materializan en patrones concretos que abordan directamente el problema de la latencia.\n\nLa latencia, en el contexto de sistemas distribuidos, se refiere al tiempo que tarda una solicitud en ser procesada y la respuesta en ser recibida.  En sistemas complejos con m\u00faltiples servicios interconectados, la latencia puede acumularse y afectar negativamente el rendimiento y la experiencia del usuario.  Las arquitecturas reactivas combaten esto mediante:\n\n**1. Asincronismo y No-Bloqueo:**  Favorecen la comunicaci\u00f3n as\u00edncrona y no bloqueante entre componentes.  En lugar de esperar una respuesta inmediata, un componente env\u00eda un mensaje y contin\u00faa con su trabajo.  Esto evita que un componente lento bloquee a otros, minimizando el impacto de la latencia de un servicio particular en el sistema completo.\n\n**2. Patrones de Resiliencia:** Implementan patrones espec\u00edficos para aislar y gestionar fallos, evitando que la latencia derivada de un fallo se propague por todo el sistema.  Dos ejemplos clave son:\n\n* **Circuit Breaker:**  Act\u00faa como un interruptor autom\u00e1tico para las llamadas a servicios externos.  Si un servicio falla repetidamente (ej., alta latencia o tiempos de espera agotados), el Circuit Breaker se \"abre\", impidiendo futuras llamadas durante un periodo de tiempo.  Esto evita que el sistema pierda recursos intentando comunicarse con un servicio no disponible, reduciendo la latencia global y protegiendo al sistema de la cascada de fallos.\n\n    **Ejemplo:** Imaginemos un servicio de recomendaciones de productos que depende de un servicio externo de inventario. Si el servicio de inventario experimenta una alta latencia o se cae, el Circuit Breaker del servicio de recomendaciones se abrir\u00e1.  En lugar de esperar indefinidamente la respuesta del servicio de inventario, el servicio de recomendaciones podr\u00eda mostrar un mensaje gen\u00e9rico (\"Recomendaciones no disponibles en este momento\") o utilizar una cach\u00e9 local, ofreciendo una respuesta degradada pero r\u00e1pida al usuario.\n\n* **Bulkheading:**  A\u00edsla diferentes partes del sistema en compartimentos estancos.  Si un componente falla, el fallo se limita a su compartimento, evitando que afecte a otros componentes.  Esto limita el impacto de la latencia causada por un fallo y mantiene la funcionalidad del resto del sistema.\n\n    **Ejemplo:** Una aplicaci\u00f3n de comercio electr\u00f3nico podr\u00eda utilizar Bulkheading para separar los servicios de carrito de compras, procesamiento de pagos y gesti\u00f3n de inventario.  Si el servicio de procesamiento de pagos experimenta una alta latencia, los usuarios a\u00fan podr\u00e1n agregar art\u00edculos al carrito y navegar por el cat\u00e1logo, ya que estos servicios operan en compartimentos separados.\n\n**3. Backpressure:**  Mecanismo para controlar el flujo de datos entre componentes.  Si un componente se ve sobrecargado y no puede procesar mensajes a la velocidad a la que los recibe, puede comunicar esta situaci\u00f3n al emisor para que reduzca la velocidad de env\u00edo.  Esto evita la saturaci\u00f3n del sistema y la consiguiente latencia.\n\n**4. Replicaci\u00f3n y Balanceo de Carga:**  Replicar servicios y distribuir la carga entre m\u00faltiples instancias reduce la latencia al evitar la congesti\u00f3n en un \u00fanico punto.  Adem\u00e1s, permite al sistema seguir funcionando incluso si una instancia falla.\n\n\nEn resumen, las arquitecturas reactivas abordan la latencia en sistemas distribuidos mediante la combinaci\u00f3n de asincronismo, patrones de resiliencia como Circuit Breaker y Bulkheading, mecanismos de backpressure, y estrategias de replicaci\u00f3n y balanceo de carga.  Estos enfoques permiten construir sistemas que son responsivos, el\u00e1sticos y resilientes a fallos y fluctuaciones en la latencia, ofreciendo una mejor experiencia al usuario.\n"}, {"numero": 9, "texto": "**Avanzado:** Dise\u00f1a un esquema de comunicaci\u00f3n entre microservicios reactivos utilizando mensajer\u00eda as\u00edncrona, justificando la elecci\u00f3n de tecnolog\u00edas como Kafka o RabbitMQ y c\u00f3mo garantizas la consistencia eventual.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "## Dise\u00f1o de un Esquema de Comunicaci\u00f3n As\u00edncrona entre Microservicios Reactivos\n\nUn sistema de microservicios reactivo se beneficia enormemente de la comunicaci\u00f3n as\u00edncrona basada en mensajes, permitiendo desacoplamiento, escalabilidad y resiliencia.  Este esquema utiliza un broker de mensajes como eje central para la comunicaci\u00f3n, facilitando la interacci\u00f3n no bloqueante entre los servicios.\n\n**Arquitectura Propuesta:**\n\nEl esquema se basa en los siguientes componentes:\n\n1. **Microservicios Reactivos:** Implementados con frameworks como Spring WebFlux o Vert.x, estos servicios consumen y producen mensajes de forma as\u00edncrona.  Su dise\u00f1o reactivo interno les permite manejar la concurrencia de manera eficiente y responder a la carga fluctuante.\n\n2. **Broker de Mensajes (Kafka/RabbitMQ):** Act\u00faa como intermediario, almacenando y distribuyendo mensajes entre los microservicios. La elecci\u00f3n entre Kafka y RabbitMQ depende de las necesidades espec\u00edficas:\n\n    * **Kafka:** Ideal para alto throughput, procesamiento de streams de datos y tolerancia a fallos a gran escala. Su arquitectura distribuida y persistencia de mensajes lo hacen robusto para escenarios de Big Data.\n\n    * **RabbitMQ:**  Adecuado para sistemas con menor volumen de datos, donde se requiere un control m\u00e1s granular sobre el routing y la entrega de mensajes. Ofrece diferentes patrones de intercambio (topic, direct, fanout) que permiten una mayor flexibilidad.\n\n3. **Topics/Exchanges y Colas:**  Mecanismos para organizar y distribuir los mensajes.  En Kafka, los mensajes se publican en topics con particiones, mientras que en RabbitMQ se utilizan exchanges para enrutar mensajes a las colas correspondientes.\n\n4. **Serializaci\u00f3n:**  Los mensajes se serializan en un formato com\u00fan, como JSON o Avro, para la interoperabilidad entre servicios.  Avro ofrece un esquema formal, lo que proporciona una mayor robustez y eficiencia.\n\n**Flujo de Comunicaci\u00f3n:**\n\n1. **Publicaci\u00f3n:** Un microservicio publica un mensaje en un topic/exchange espec\u00edfico.\n2. **Suscripci\u00f3n:**  Los microservicios interesados se suscriben a ese topic/exchange o a las colas correspondientes.\n3. **Consumo:** El broker de mensajes entrega los mensajes a los suscriptores de forma as\u00edncrona.\n4. **Procesamiento:** Los microservicios procesan los mensajes y pueden, a su vez, publicar nuevos mensajes como respuesta.\n\n**Garantizando la Consistencia Eventual:**\n\nLa consistencia eventual es crucial en sistemas distribuidos as\u00edncronos.  Para garantizarla, se pueden emplear las siguientes estrategias:\n\n1. **Patrones de Saga:**  Orquestan una secuencia de transacciones locales en diferentes microservicios.  En caso de fallo, se ejecutan compensaciones para revertir los cambios y mantener la consistencia.  Se pueden implementar sagas de orquestaci\u00f3n o coreograf\u00eda.\n\n2. **Manejo Idempotente de Mensajes:**  Los microservicios deben ser capaces de procesar el mismo mensaje m\u00faltiples veces sin efectos secundarios no deseados.  Esto se logra asignando identificadores \u00fanicos a los mensajes y rastreando su procesamiento.\n\n3. **Control de Versiones de Eventos:**  Incluir la versi\u00f3n del evento en el mensaje permite a los consumidores manejar diferentes versiones de los eventos y aplicar la l\u00f3gica adecuada seg\u00fan la versi\u00f3n recibida.\n\n4. **Retenci\u00f3n de Mensajes:**  Configurar el broker para retener mensajes durante un per\u00edodo de tiempo permite a los nuevos suscriptores acceder al historial de eventos y alcanzar la consistencia eventual.\n\n5. **Monitorizaci\u00f3n y Logging:**  Un sistema de monitorizaci\u00f3n robusto es esencial para rastrear el flujo de mensajes, detectar errores y asegurar la entrega de mensajes.  El logging detallado facilita la depuraci\u00f3n y el an\u00e1lisis del sistema.\n\n**Ejemplo con Kafka:**\n\nUn microservicio de \"Pedidos\" publica un evento \"PedidoCreado\" en el topic \"pedidos\".  Los microservicios de \"Inventario\" y \"Facturaci\u00f3n\" se suscriben a este topic.  Al recibir el evento, \"Inventario\" actualiza el stock y \"Facturaci\u00f3n\" genera la factura.  Cada microservicio maneja sus transacciones locales y utiliza estrategias de manejo idempotente para asegurar la consistencia eventual.\n\n**Conclusi\u00f3n:**\n\nEste esquema de comunicaci\u00f3n as\u00edncrona con Kafka o RabbitMQ proporciona un marco robusto y escalable para la interacci\u00f3n entre microservicios reactivos.  La elecci\u00f3n del broker, la implementaci\u00f3n de patrones de saga y el manejo idempotente de mensajes son cruciales para garantizar la consistencia eventual y la resiliencia del sistema.  Una monitorizaci\u00f3n adecuada y un logging detallado son esenciales para la operaci\u00f3n y el mantenimiento del sistema.\n"}, {"numero": 10, "texto": "**Intermedio**: Compara y contrasta el modelo de actores con los sistemas basados en eventos en arquitecturas reactivas, destacando ventajas, desventajas y casos de uso t\u00edpicos para cada uno.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "## Comparaci\u00f3n y Contraste entre el Modelo de Actores y Sistemas Basados en Eventos en Arquitecturas Reactivas\n\nTanto el modelo de actores como los sistemas basados en eventos son enfoques populares para construir arquitecturas reactivas, permitiendo la creaci\u00f3n de sistemas altamente concurrentes, escalables y resilientes. Sin embargo, difieren en su forma de manejar el estado, la comunicaci\u00f3n y la concurrencia.\n\n**Modelo de Actores:**\n\n* **Principios:**  Se basa en \"actores\" independientes que encapsulan estado y comportamiento. Los actores se comunican exclusivamente mediante el intercambio de mensajes asincr\u00f3nicos, evitando el acceso compartido a la memoria y los problemas de concurrencia tradicionales.  Cada actor tiene un buz\u00f3n donde recibe mensajes y los procesa secuencialmente.\n\n* **Ventajas:**\n    * **Simplicidad en la concurrencia:** La naturaleza asincr\u00f3nica y el aislamiento del estado simplifican el manejo de la concurrencia, evitando deadlocks y race conditions.\n    * **Escalabilidad:**  Los actores pueden distribuirse f\u00e1cilmente en m\u00faltiples nodos, permitiendo la escalabilidad horizontal.\n    * **Resiliencia:**  El fallo de un actor no afecta a otros, promoviendo la tolerancia a fallos.\n    * **Abstracci\u00f3n:** El modelo de actores ofrece una abstracci\u00f3n de alto nivel que simplifica el dise\u00f1o y la implementaci\u00f3n de sistemas complejos.\n\n* **Desventajas:**\n    * **Complejidad de depuraci\u00f3n:** El flujo de mensajes asincr\u00f3nico puede dificultar la depuraci\u00f3n y el seguimiento del estado del sistema.\n    * **Sobrecarga de mensajes:**  La comunicaci\u00f3n exclusivamente por mensajes puede generar una sobrecarga, especialmente en sistemas con alta interacci\u00f3n entre actores.\n    * **Curva de aprendizaje:**  El paradigma de actores puede requerir un cambio de mentalidad para desarrolladores acostumbrados a modelos de programaci\u00f3n imperativos.\n\n* **Casos de uso t\u00edpicos:**\n    * **Sistemas distribuidos:** Plataformas de comercio electr\u00f3nico, redes sociales, juegos online.\n    * **Procesamiento de flujos de datos (streaming):** An\u00e1lisis de datos en tiempo real, procesamiento de eventos complejos.\n    * **Simulaciones:** Modelado de sistemas complejos con m\u00faltiples agentes interactuando.\n\n\n**Sistemas Basados en Eventos:**\n\n* **Principios:** Se centran en la propagaci\u00f3n de eventos a trav\u00e9s de un bus de eventos o un sistema de mensajer\u00eda. Los componentes se suscriben a eventos de inter\u00e9s y reaccionan a ellos. El estado se gestiona t\u00edpicamente en una base de datos o un almac\u00e9n de datos separado.\n\n* **Ventajas:**\n    * **Acoplamiento flexible:** Los componentes est\u00e1n d\u00e9bilmente acoplados, ya que no necesitan conocerse directamente.  Facilitan la evoluci\u00f3n y el mantenimiento del sistema.\n    * **Escalabilidad:**  La arquitectura basada en eventos permite escalar horizontalmente al agregar m\u00e1s consumidores de eventos.\n    * **Extensibilidad:**  Es f\u00e1cil agregar nuevas funcionalidades al sistema simplemente suscribi\u00e9ndose a los eventos relevantes.\n    * **Auditoria:**  El registro de eventos proporciona una pista de auditor\u00eda completa de las acciones del sistema.\n\n* **Desventajas:**\n    * **Consistencia eventual:**  La naturaleza asincr\u00f3nica de los eventos puede llevar a la consistencia eventual, lo que puede ser problem\u00e1tico en algunos casos.\n    * **Complejidad de gesti\u00f3n de eventos:**  La gesti\u00f3n de un gran n\u00famero de eventos y suscripciones puede volverse compleja.\n    * **Depuraci\u00f3n:**  Rastrear el flujo de eventos y depurar problemas puede ser desafiante.\n\n\n* **Casos de uso t\u00edpicos:**\n    * **Microservicios:** Comunicaci\u00f3n as\u00edncrona entre microservicios.\n    * **Aplicaciones en tiempo real:**  Monitoreo de sistemas, notificaciones en tiempo real.\n    * **Integraci\u00f3n de sistemas:**  Conexi\u00f3n de diferentes sistemas a trav\u00e9s de eventos.\n\n\n**Conclusi\u00f3n:**\n\nTanto el modelo de actores como los sistemas basados en eventos son herramientas valiosas para construir arquitecturas reactivas. La elecci\u00f3n entre ambos depende de las necesidades espec\u00edficas del proyecto.  El modelo de actores es ideal para sistemas con alta concurrencia y donde el estado es crucial, mientras que los sistemas basados en eventos son m\u00e1s adecuados para sistemas con acoplamiento flexible y extensibilidad.  En algunos casos, incluso se pueden combinar ambos enfoques para aprovechar las ventajas de cada uno.  Por ejemplo, se pueden utilizar actores para procesar eventos complejos dentro de un sistema basado en eventos m\u00e1s amplio.\n"}], "casos_uso": [{"numero": 11, "descripcion": "1. **Caso de uso 1: Sistema de reservas en tiempo real para un cine**  \n   - **Escenario**: Un cine necesita un sistema que permita a los usuarios reservar asientos en tiempo real, evitando conflictos cuando m\u00faltiples usuarios intentan reservar el mismo asiento simult\u00e1neamente.  \n   - **Requisitos**:  \n     - Implementar un sistema reactivo que notifique a los usuarios cuando un asiento ya est\u00e1 ocupado.  \n     - Garantizar la consistencia de los datos en alta concurrencia.  \n   - **Herramientas sugeridas**: Akka (Actor Model), WebSockets, Base de datos con soporte para transacciones (PostgreSQL).  \n\n", "pregunta": "Desarrolle una soluci\u00f3n para el caso descrito anteriormente", "puntaje": 1, "respuestaAlumno": "", "archivoSubido": false, "respuestaProfesor": ""}]}, "createdAt": "2025-04-30T14:57:28.278944", "expiration": "2025-05-07T19:57:28.225Z", "publicAccess": true}