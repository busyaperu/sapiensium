{"id": "78318a32", "examenData": {"id": "069934", "nombreExamen": "Programaci\u00f3n UML", "tipoExamen": "Evaluaci\u00f3n", "fecha": "2025-04-29", "profesor": "Mariela Isabel Camargo Rom\u00e1n", "profesorId": "16MI987", "nombreAlumno": "", "idAlumno": "", "bloqueado": true, "preguntasMarcar": [{"numero": 1, "texto": "\u00bfQu\u00e9 patr\u00f3n de dise\u00f1o es com\u00fan en sistemas reactivos para manejar flujos de datos as\u00edncronos?  \nA) Singleton  \nB) Observer  \nC) Factory  \nD) Decorator  \nE) Strategy", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 0}, {"numero": 2, "texto": "\u00bfQu\u00e9 componente de las arquitecturas reactivas se encarga de manejar la comunicaci\u00f3n entre servicios?  \nA) Base de datos relacional  \nB) Message Broker  \nC) Load Balancer  \nD) Servidor web  \nE) Cache distribuida", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 2}, {"numero": 3, "texto": "\u00bfCu\u00e1l de las siguientes tecnolog\u00edas es ampliamente utilizada para implementar sistemas reactivos?  \nA) ReactJS  \nB) Akka  \nC) Django  \nD) Spring MVC  \nE) Hibernate", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 3}, {"numero": 4, "texto": "\u00bfQu\u00e9 caracter\u00edstica define a un sistema reactivo seg\u00fan el Manifiesto Reactivo?  \nA) Respuesta lenta  \nB) Escalabilidad limitada  \nC) Resiliencia  \nD) Acoplamiento fuerte  \nE) Procesamiento en batch", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 4}, {"numero": 5, "texto": "\u00bfQu\u00e9 t\u00e9rmino describe la capacidad de un sistema reactivo para responder a fluctuaciones en la carga?  \nA) Elasticidad  \nB) Fragmentaci\u00f3n  \nC) Serializaci\u00f3n  \nD) Normalizaci\u00f3n  \nE) Compilaci\u00f3n", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 0}, {"numero": 6, "texto": "\u00bfCu\u00e1l de los siguientes principios es clave en las arquitecturas reactivas?  \nA) Acoplamiento fuerte entre componentes  \nB) Tolerancia al bloqueo en las operaciones  \nC) Responsividad ante fallos y cargas variables  \nD) Dependencia de hardware especializado  \nE) Uso exclusivo de lenguajes de bajo nivel", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 3}, {"numero": 7, "texto": "\u00bfQu\u00e9 patr\u00f3n de dise\u00f1o es com\u00fan en sistemas reactivos para manejar flujos de datos?  \nA) Singleton  \nB) Observer  \nC) Factory  \nD) Decorator  \nE) Prototype", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 2}, {"numero": 8, "texto": "\u00bfQu\u00e9 herramienta se usa a menudo para implementar programaci\u00f3n reactiva en JavaScript?  \nA) Django  \nB) Reactor  \nC) RxJS  \nD) Hibernate  \nE) JUnit", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 3}, {"numero": 9, "texto": "\u00bfQu\u00e9 beneficio principal ofrece el \"backpressure\" en sistemas reactivos?  \nA) Eliminar la necesidad de manejar errores  \nB) Controlar la velocidad de procesamiento entre componentes  \nC) Reducir el uso de memoria est\u00e1tica  \nD) Aumentar el acoplamiento entre m\u00f3dulos  \nE) Simplificar el despliegue en la nube", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 2}, {"numero": 10, "texto": "\u00bfCu\u00e1l de estos lenguajes NO es com\u00fanmente asociado con programaci\u00f3n reactiva?  \nA) Java  \nB) Python  \nC) C#  \nD) COBOL  \nE) Scala", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 0}], "preguntasLibres": [{"numero": 11, "texto": "**Intermedio:** Compara las arquitecturas reactivas con las arquitecturas tradicionales (como MVC), destacando ventajas, desventajas y casos de uso apropiados para cada una.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "## Arquitecturas Reactivas vs. Arquitecturas Tradicionales (e.g., MVC)\n\nLas arquitecturas reactivas y las tradicionales, como el Modelo-Vista-Controlador (MVC), representan enfoques diferentes para el dise\u00f1o y desarrollo de software.  Mientras que MVC se centra en la organizaci\u00f3n del c\u00f3digo y la separaci\u00f3n de responsabilidades, las arquitecturas reactivas priorizan la respuesta a eventos y la propagaci\u00f3n de cambios de forma eficiente.  A continuaci\u00f3n, se presenta una comparaci\u00f3n detallada:\n\n**Arquitecturas Tradicionales (e.g., MVC):**\n\n* **Principio fundamental:** Separaci\u00f3n de responsabilidades en Modelo (datos), Vista (interfaz de usuario) y Controlador (l\u00f3gica de negocio).  El flujo de informaci\u00f3n suele ser s\u00edncrono y basado en peticiones/respuestas.\n* **Ventajas:**\n    * **Simplicidad y familiaridad:**  MVC es un patr\u00f3n ampliamente conocido y utilizado, lo que facilita su aprendizaje y aplicaci\u00f3n.\n    * **Estructura clara:** La separaci\u00f3n de responsabilidades facilita el mantenimiento y la evoluci\u00f3n del c\u00f3digo.\n    * **F\u00e1cil de depurar:** El flujo de ejecuci\u00f3n es generalmente lineal y predecible.\n* **Desventajas:**\n    * **Escalabilidad limitada:**  El manejo de un alto volumen de peticiones concurrentes puede ser un desaf\u00edo.\n    * **Complejidad en aplicaciones grandes:** A medida que la aplicaci\u00f3n crece, la comunicaci\u00f3n entre componentes puede volverse compleja.\n    * **No optimizado para datos en tiempo real:** MVC no se adapta f\u00e1cilmente a escenarios donde los datos cambian constantemente.\n* **Casos de uso apropiados:**\n    * Aplicaciones web tradicionales con un flujo de datos predecible.\n    * Aplicaciones CRUD (Crear, Leer, Actualizar, Eliminar) simples.\n    * Proyectos peque\u00f1os a medianos con requisitos de escalabilidad moderados.\n\n\n**Arquitecturas Reactivas:**\n\n* **Principio fundamental:**  Basadas en el Manifiesto Reactivo, estas arquitecturas se centran en la construcci\u00f3n de sistemas **responsivos, resilientes, el\u00e1sticos y orientados a mensajes**.  La propagaci\u00f3n de cambios se realiza de forma as\u00edncrona y eficiente.\n* **Ventajas:**\n    * **Alta escalabilidad:**  El manejo de un gran volumen de datos y peticiones concurrentes es m\u00e1s eficiente.\n    * **Mayor resiliencia:**  El dise\u00f1o basado en mensajes permite aislar fallos y mantener la disponibilidad del sistema.\n    * **Optimizado para datos en tiempo real:**  Ideal para aplicaciones con flujos de datos constantes y cambiantes, como streaming o chat.\n* **Desventajas:**\n    * **Mayor complejidad:**  Requiere un cambio de paradigma en el dise\u00f1o y desarrollo de software.\n    * **Curva de aprendizaje m\u00e1s pronunciada:**  Dominar los conceptos de programaci\u00f3n reactiva puede ser un desaf\u00edo.\n    * **Depuraci\u00f3n m\u00e1s compleja:**  El flujo de datos as\u00edncrono puede dificultar la identificaci\u00f3n de errores.\n* **Casos de uso apropiados:**\n    * Aplicaciones en tiempo real, como chat, juegos online y dashboards.\n    * Sistemas de alta disponibilidad y escalabilidad, como plataformas de streaming y comercio electr\u00f3nico.\n    * Aplicaciones que procesan grandes vol\u00famenes de datos, como an\u00e1lisis de Big Data.\n\n\n**Tabla comparativa:**\n\n| Caracter\u00edstica | Arquitectura Tradicional (e.g., MVC) | Arquitectura Reactiva |\n|---|---|---|\n| **Principio fundamental** | Separaci\u00f3n de responsabilidades | Responsividad, resiliencia, elasticidad, orientaci\u00f3n a mensajes |\n| **Escalabilidad** | Limitada | Alta |\n| **Resiliencia** | Moderada | Alta |\n| **Manejo de datos en tiempo real** | No optimizado | Optimizado |\n| **Complejidad** | Menor | Mayor |\n| **Curva de aprendizaje** | Menor | Mayor |\n\n\n**Conclusi\u00f3n:**\n\nLa elecci\u00f3n entre una arquitectura reactiva y una tradicional depende de las necesidades espec\u00edficas del proyecto.  MVC es una opci\u00f3n s\u00f3lida para aplicaciones simples y bien definidas, mientras que las arquitecturas reactivas son m\u00e1s adecuadas para sistemas complejos, escalables y que requieren un alto grado de responsividad.  Es importante evaluar cuidadosamente las ventajas y desventajas de cada enfoque antes de tomar una decisi\u00f3n.\n"}, {"numero": 12, "texto": "**Avanzado:** Analiza c\u00f3mo el patr\u00f3n *Event Sourcing* puede integrarse en una arquitectura reactiva para mejorar la resiliencia y escalabilidad. Proporciona un ejemplo concreto.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "## Integraci\u00f3n de Event Sourcing en una Arquitectura Reactiva para Mejorar la Resiliencia y Escalabilidad\n\nEl patr\u00f3n *Event Sourcing* se integra de manera sin\u00e9rgica con las arquitecturas reactivas para construir sistemas altamente resilientes y escalables. En esencia, *Event Sourcing* persiste el estado de una aplicaci\u00f3n como una secuencia inmutable de eventos, en lugar de actualizar directamente el estado actual.  Esta caracter\u00edstica clave habilita las propiedades reactivas de **responsividad, resiliencia, elasticidad y orientaci\u00f3n a mensajes**.\n\n**\u00bfC\u00f3mo mejora Event Sourcing la resiliencia?**\n\n* **Recuperaci\u00f3n ante fallos simplificada:** Si un componente falla, puede reconstruir su estado reproduciendo los eventos relevantes desde el principio o desde un *snapshot*.  Esto elimina la dependencia de bases de datos transaccionales complejas y facilita la recuperaci\u00f3n.\n* **Auditor\u00eda y depuraci\u00f3n mejoradas:**  El registro inmutable de eventos proporciona una pista de auditor\u00eda completa de todos los cambios en el sistema. Esto facilita la identificaci\u00f3n de la causa ra\u00edz de los problemas y la depuraci\u00f3n de errores.\n* **Consistencia eventual:**  En arquitecturas distribuidas, la consistencia eventual es a menudo preferible a la consistencia fuerte para mejorar la disponibilidad. *Event Sourcing* facilita la consistencia eventual al propagar los eventos de forma as\u00edncrona a los diferentes componentes del sistema.\n\n**\u00bfC\u00f3mo mejora Event Sourcing la escalabilidad?**\n\n* **Lectura y escritura desacopladas:** La separaci\u00f3n entre la escritura de eventos y la lectura del estado permite escalar cada parte de forma independiente. Los eventos se pueden escribir en un *log* de alta velocidad, mientras que las proyecciones del estado se pueden optimizar para consultas espec\u00edficas.\n* **CQRS (Command Query Responsibility Segregation):** *Event Sourcing* se combina a menudo con CQRS, lo que permite optimizar las operaciones de lectura y escritura por separado. Las consultas se ejecutan contra vistas materializadas generadas a partir de los eventos, lo que mejora el rendimiento de lectura.\n* **Procesamiento paralelo:** Los eventos se pueden procesar en paralelo por m\u00faltiples consumidores, lo que permite escalar horizontalmente el sistema.\n\n\n**Ejemplo concreto: Una plataforma de comercio electr\u00f3nico**\n\nImaginemos una plataforma de comercio electr\u00f3nico que utiliza *Event Sourcing*.  Cuando un cliente realiza un pedido, se genera un evento `OrderCreated`. Este evento se persiste en un *event store* (ej. Kafka, Apache Pulsar).  \n\nDiversos microservicios reaccionan a este evento:\n\n* **Servicio de inventario:**  Recibe el evento `OrderCreated` y reduce el stock de los productos pedidos.  Genera un evento `InventoryUpdated`.\n* **Servicio de facturaci\u00f3n:** Recibe el evento `OrderCreated` y genera una factura. Genera un evento `InvoiceCreated`.\n* **Servicio de env\u00edo:** Recibe el evento `OrderCreated` y programa el env\u00edo. Genera un evento `ShippingScheduled`.\n\nCada microservicio mantiene su propio estado reconstruy\u00e9ndolo a partir de los eventos relevantes.  Si el servicio de inventario falla, puede reconstruir su estado reproduciendo los eventos `InventoryUpdated`.\n\nAdem\u00e1s, se pueden crear vistas materializadas para consultas espec\u00edficas.  Por ejemplo, se puede crear una vista que muestre el estado actual de un pedido combinando los eventos `OrderCreated`, `InventoryUpdated`, `InvoiceCreated` y `ShippingScheduled`.  Esta vista se actualiza as\u00edncronamente a medida que se generan nuevos eventos.\n\n\n**Conclusi\u00f3n:**\n\n*Event Sourcing*, combinado con una arquitectura reactiva, ofrece una potente soluci\u00f3n para construir sistemas resilientes y escalables.  Al persistir el estado como una secuencia inmutable de eventos, se facilita la recuperaci\u00f3n ante fallos, la auditor\u00eda, la escalabilidad y la consistencia eventual.  Este patr\u00f3n es particularmente adecuado para sistemas distribuidos complejos con altos requisitos de disponibilidad y rendimiento.  Sin embargo, introduce complejidad adicional en el dise\u00f1o y la implementaci\u00f3n, por lo que es crucial evaluar cuidadosamente si es la soluci\u00f3n adecuada para un proyecto espec\u00edfico.\n"}, {"numero": 13, "texto": "**Intermedio:** Describe c\u00f3mo se maneja el backpressure en sistemas reactivos y qu\u00e9 estrategias pueden implementarse para gestionarlo eficientemente.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "## Manejo de Backpressure en Sistemas Reactivos\n\nEn sistemas reactivos, el backpressure se refiere a la situaci\u00f3n en la que un componente productor de datos genera informaci\u00f3n a una velocidad mayor a la que un componente consumidor puede procesarla.  Esta disparidad puede llevar a la saturaci\u00f3n de buffers, p\u00e9rdida de datos, latencia incrementada e incluso fallos del sistema.  Es crucial entender c\u00f3mo se maneja el backpressure para construir sistemas reactivos robustos y resilientes.\n\nEl manejo efectivo del backpressure se basa en el principio de **control de flujo**, permitiendo al consumidor regular la velocidad a la que recibe datos del productor.  En lugar de un flujo unidireccional, se establece una comunicaci\u00f3n bidireccional donde el consumidor comunica su capacidad de procesamiento al productor.\n\n**Mecanismos de Manejo de Backpressure:**\n\nExisten varias estrategias para implementar el control de flujo y gestionar el backpressure:\n\n1. **Buffering:**  Una estrategia simple es utilizar buffers intermedios para almacenar temporalmente los datos producidos.  Si el consumidor es m\u00e1s lento, el buffer se llena; si es m\u00e1s r\u00e1pido, el buffer se vac\u00eda.  Sin embargo, el buffering solo pospone el problema. Si la diferencia de velocidad es persistente, el buffer eventualmente se desbordar\u00e1.  Por lo tanto, el buffering es m\u00e1s efectivo cuando las fluctuaciones de velocidad son temporales y no muy significativas.\n\n2. **Control de Flujo Expl\u00edcito:**  Esta estrategia implica una comunicaci\u00f3n directa entre el productor y el consumidor.  El consumidor solicita expl\u00edcitamente una cantidad espec\u00edfica de datos o indica su capacidad de procesamiento al productor.  Ejemplos de mecanismos de control de flujo expl\u00edcito incluyen:\n\n    * **Pull-based systems (Sistemas basados en extracci\u00f3n):** El consumidor solicita datos al productor seg\u00fan su necesidad.  El productor solo env\u00eda datos cuando se le solicitan.  Ejemplos incluyen la paginaci\u00f3n en APIs REST o el uso de iteradores.\n    * **Explicit signaling (Se\u00f1alizaci\u00f3n expl\u00edcita):** El consumidor env\u00eda se\u00f1ales al productor para indicar su capacidad de procesamiento.  El productor ajusta su velocidad de producci\u00f3n en base a estas se\u00f1ales.\n\n\n3. **Control de Flujo Impl\u00edcito:**  En este enfoque, el control de flujo se maneja de forma impl\u00edcita a trav\u00e9s del mecanismo de transporte o el framework reactivo.  Ejemplos incluyen:\n\n    * **TCP Flow Control:**  El protocolo TCP implementa control de flujo a nivel de red para evitar la congesti\u00f3n.\n    * **Reactive Streams (Flujos Reactivos):**  El est\u00e1ndar Reactive Streams define una interfaz para el control de flujo reactivo, permitiendo la interoperabilidad entre diferentes bibliotecas reactivas.  Utiliza un mecanismo de solicitud/suscripci\u00f3n donde el consumidor solicita una cantidad de datos y el productor responde enviando los datos o una se\u00f1al de error.\n\n\n**Estrategias para una Gesti\u00f3n Eficiente del Backpressure:**\n\nPara gestionar el backpressure eficientemente, se pueden aplicar las siguientes estrategias:\n\n* **Monitoreo:**  Es fundamental monitorear las m\u00e9tricas clave como el tama\u00f1o del buffer, la tasa de producci\u00f3n y la tasa de consumo para detectar posibles problemas de backpressure.\n* **Escalabilidad:**  Dise\u00f1ar el sistema para ser escalable permite aumentar la capacidad de procesamiento del consumidor cuando sea necesario.\n* **Degradaci\u00f3n elegante:**  Implementar mecanismos de degradaci\u00f3n elegante, como descartar datos menos importantes o reducir la calidad del servicio, permite al sistema seguir funcionando bajo presi\u00f3n.\n* **Retroalimentaci\u00f3n:**  Proporcionar retroalimentaci\u00f3n al usuario sobre el estado del sistema y las posibles demoras puede mejorar la experiencia del usuario.\n* **Selecci\u00f3n de la estrategia adecuada:**  La estrategia de backpressure m\u00e1s adecuada depende de las caracter\u00edsticas espec\u00edficas del sistema, como la naturaleza de los datos, la tolerancia a la latencia y la complejidad de la implementaci\u00f3n.\n\n\nEn resumen, el backpressure es un aspecto crucial del dise\u00f1o de sistemas reactivos.  Implementar estrategias de control de flujo y aplicar las mejores pr\u00e1cticas para la gesti\u00f3n del backpressure garantiza la robustez, resiliencia y rendimiento del sistema bajo diferentes condiciones de carga.  La elecci\u00f3n de la estrategia correcta depende de las necesidades espec\u00edficas del sistema, y una comprensi\u00f3n profunda de las diferentes opciones disponibles es esencial para construir sistemas reactivos exitosos.\n"}, {"numero": 14, "texto": "**Avanzado:** Dise\u00f1a una arquitectura reactiva para un sistema de comercio electr\u00f3nico de alta demanda, explicando c\u00f3mo garantizar\u00edas escalabilidad, baja latencia y tolerancia a fallos.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "## Arquitectura Reactiva para un Sistema de Comercio Electr\u00f3nico de Alta Demanda\n\nUn sistema de comercio electr\u00f3nico de alta demanda requiere una arquitectura que pueda manejar un gran volumen de transacciones concurrentes con baja latencia y alta disponibilidad. Una arquitectura reactiva, basada en los principios del Manifiesto Reactivo, es ideal para este prop\u00f3sito. A continuaci\u00f3n, se describe una arquitectura reactiva para un sistema de comercio electr\u00f3nico, enfoc\u00e1ndose en la escalabilidad, baja latencia y tolerancia a fallos:\n\n**1. Componentes Principales:**\n\n* **API Gateway:** Punto de entrada para todas las solicitudes.  Utiliza un balanceador de carga para distribuir el tr\u00e1fico a los microservicios.\n* **Microservicios:** Funcionalidades descompuestas en servicios independientes (ej. cat\u00e1logo, carrito, pedidos, pagos, env\u00edos, usuarios).  Cada microservicio tiene su propia base de datos y se comunica con otros a trav\u00e9s de mensajes as\u00edncronos.\n* **Bus de Mensajes (ej. Kafka, RabbitMQ):** Facilita la comunicaci\u00f3n as\u00edncrona entre microservicios.  Permite desacoplamiento y escalabilidad independiente.\n* **Base de Datos Reactiva (ej. Cassandra, MongoDB):**  Ofrece alta disponibilidad, escalabilidad horizontal y consistencia eventual.  Se adapta bien a la naturaleza distribuida del sistema.\n* **Cach\u00e9 Distribuida (ej. Redis, Memcached):** Almacena datos frecuentemente accedidos para reducir la latencia y la carga en la base de datos.\n* **Sistema de Monitorizaci\u00f3n (ej. Prometheus, Grafana):**  Proporciona visibilidad del rendimiento del sistema, permitiendo la detecci\u00f3n temprana de problemas y la optimizaci\u00f3n.\n\n**2. Escalabilidad:**\n\n* **Escalabilidad Horizontal:** Los microservicios, la base de datos reactiva y la cach\u00e9 distribuida pueden escalarse horizontalmente agregando m\u00e1s nodos al cl\u00faster seg\u00fan la demanda.  El bus de mensajes gestiona la distribuci\u00f3n de la carga entre los nodos.\n* **Backpressure:** Mecanismo para controlar el flujo de datos entre componentes, evitando la sobrecarga del sistema.  Un componente sobrecargado puede solicitar a los componentes upstream que reduzcan la velocidad de env\u00edo de datos.\n* **Stateless Services:** Los microservicios son stateless, lo que facilita el escalado horizontal y la tolerancia a fallos.  El estado se almacena en la base de datos o la cach\u00e9 distribuida.\n\n**3. Baja Latencia:**\n\n* **Comunicaci\u00f3n As\u00edncrona:** El uso de un bus de mensajes permite el procesamiento as\u00edncrono de solicitudes, evitando bloqueos y reduciendo la latencia.\n* **Cach\u00e9 Distribuida:** El almacenamiento en cach\u00e9 de datos frecuentemente accedidos reduce el tiempo de respuesta a las solicitudes.\n* **Optimizaci\u00f3n de Consultas a la Base de Datos:** Dise\u00f1o eficiente del esquema de la base de datos y uso de \u00edndices para acelerar las consultas.\n\n**4. Tolerancia a Fallos:**\n\n* **Replicaci\u00f3n:** Los microservicios, la base de datos reactiva y la cach\u00e9 distribuida se replican en m\u00faltiples nodos para garantizar la disponibilidad en caso de fallo de un nodo.\n* **Circuit Breaker:**  Patr\u00f3n de dise\u00f1o que previene la cascada de fallos en el sistema.  Si un servicio falla repetidamente, el circuit breaker se abre, evitando que otras solicitudes lleguen al servicio fallido.\n* **Supervisi\u00f3n y Alertas:** El sistema de monitorizaci\u00f3n detecta fallos y env\u00eda alertas para que se tomen medidas correctivas.\n* **Fallback Mechanisms:**  Implementaci\u00f3n de mecanismos de fallback para proporcionar una respuesta degradada en caso de fallo de un servicio.\n\n\n**5. Ejemplo de Flujo de una Transacci\u00f3n:**\n\n1. El usuario agrega un producto al carrito a trav\u00e9s de la API Gateway.\n2. La API Gateway redirige la solicitud al microservicio de carrito.\n3. El microservicio de carrito publica un evento en el bus de mensajes.\n4. El microservicio de inventario consume el evento y actualiza el inventario.\n5. El microservicio de carrito confirma la operaci\u00f3n al usuario.\n\n**Conclusi\u00f3n:**\n\nEsta arquitectura reactiva proporciona una base s\u00f3lida para un sistema de comercio electr\u00f3nico de alta demanda.  La combinaci\u00f3n de microservicios, comunicaci\u00f3n as\u00edncrona, base de datos reactiva y cach\u00e9 distribuida permite lograr escalabilidad, baja latencia y tolerancia a fallos.  La monitorizaci\u00f3n continua y la implementaci\u00f3n de patrones de dise\u00f1o como circuit breaker y backpressure son cruciales para garantizar la resiliencia del sistema.  La modularidad de la arquitectura facilita la evoluci\u00f3n y la adaptaci\u00f3n a las cambiantes necesidades del negocio.\n"}, {"numero": 15, "texto": "**Intermedio**: Compara y contrasta el enfoque de la programaci\u00f3n reactiva con el paradigma tradicional orientado a objetos, destacando ventajas y desventajas en el manejo de flujos de datos as\u00edncronos.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "## Comparaci\u00f3n entre Programaci\u00f3n Reactiva y Programaci\u00f3n Orientada a Objetos en el manejo de flujos de datos as\u00edncronos\n\nLa programaci\u00f3n orientada a objetos (POO) y la programaci\u00f3n reactiva (PR) son dos paradigmas de programaci\u00f3n que ofrecen enfoques distintos para el desarrollo de software, especialmente en el manejo de flujos de datos as\u00edncronos. Si bien pueden coexistir y complementarse, sus filosof\u00edas centrales difieren significativamente.\n\n**Programaci\u00f3n Orientada a Objetos (POO):**\n\n* **Enfoque:** Se centra en la organizaci\u00f3n del c\u00f3digo en objetos que encapsulan datos y m\u00e9todos. La interacci\u00f3n entre objetos se realiza a trav\u00e9s de llamadas a m\u00e9todos, generalmente de forma s\u00edncrona.  Para manejar asincron\u00eda, la POO tradicionalmente utiliza callbacks, promesas o async/await.\n* **Manejo de asincron\u00eda:** En POO, el manejo de flujos as\u00edncronos puede volverse complejo con el incremento de las interacciones.  Callbacks anidados (\"callback hell\") dificultan la lectura y el mantenimiento del c\u00f3digo. Promesas y async/await mejoran la situaci\u00f3n, pero la l\u00f3gica as\u00edncrona sigue estando dispersa en el c\u00f3digo.\n* **Ventajas:**\n    * **Modularidad y Reusabilidad:** Facilita la creaci\u00f3n de componentes reutilizables y bien definidos.\n    * **Encapsulaci\u00f3n:** Protege los datos y la l\u00f3gica interna de los objetos.\n    * **F\u00e1cil de aprender (inicialmente):**  Los conceptos b\u00e1sicos de POO son relativamente sencillos de comprender.\n* **Desventajas (en el contexto de asincron\u00eda):**\n    * **Complejidad en la gesti\u00f3n de flujos as\u00edncronos complejos:** Callbacks anidados, manejo de errores disperso.\n    * **Dificultad para la composici\u00f3n de operaciones as\u00edncronas:** Combinar m\u00faltiples flujos as\u00edncronos puede ser engorroso.\n    * **Estado mutable:**  La gesti\u00f3n del estado en aplicaciones as\u00edncronas puede ser propensa a errores.\n\n\n**Programaci\u00f3n Reactiva (PR):**\n\n* **Enfoque:** Se basa en el concepto de flujos de datos as\u00edncronos y la propagaci\u00f3n de cambios. Los datos se representan como flujos observables (streams) a los que los componentes pueden suscribirse.  Cuando el valor de un flujo cambia, las notificaciones se propagan autom\u00e1ticamente a los suscriptores.\n* **Manejo de asincron\u00eda:** La PR simplifica el manejo de asincron\u00eda al tratar los datos como flujos continuos.  Los operadores como `map`, `filter`, `flatMap` permiten transformar y combinar flujos de forma declarativa, evitando callbacks anidados y facilitando la composici\u00f3n.\n* **Ventajas:**\n    * **Simplifica el c\u00f3digo as\u00edncrono:**  Elimina la necesidad de callbacks anidados y facilita la composici\u00f3n de operaciones as\u00edncronas.\n    * **Manejo de errores centralizado:**  Los flujos pueden manejar errores de forma integrada.\n    * **Mayor eficiencia:** Permite optimizar el uso de recursos al procesar datos as\u00edncronos de forma eficiente.\n    * **Mejor manejo del estado:**  Facilita la implementaci\u00f3n de patrones como Redux o MobX para una gesti\u00f3n de estado m\u00e1s robusta.\n* **Desventajas:**\n    * **Curva de aprendizaje m\u00e1s pronunciada:**  Requiere comprender conceptos como observables, operadores y programaci\u00f3n funcional reactiva.\n    * **Debugging puede ser m\u00e1s complejo:**  Rastrear el flujo de datos a trav\u00e9s de m\u00faltiples operadores puede ser desafiante.\n    * **Overkill para aplicaciones simples:**  Para aplicaciones con poca asincron\u00eda, la PR puede a\u00f1adir complejidad innecesaria.\n\n\n\n**Tabla comparativa:**\n\n| Caracter\u00edstica | POO | PR |\n|---|---|---|\n| Enfoque | Objetos y m\u00e9todos | Flujos de datos y propagaci\u00f3n de cambios |\n| Manejo de asincron\u00eda | Callbacks, Promesas, Async/await | Observables y operadores |\n| Complejidad as\u00edncrona | Alta | Baja |\n| Composici\u00f3n as\u00edncrona | Dif\u00edcil | F\u00e1cil |\n| Manejo de errores | Disperso | Centralizado |\n| Curva de aprendizaje | Inicialmente baja, alta para asincron\u00eda compleja | Alta |\n\n\n**Conclusi\u00f3n:**\n\nLa POO y la PR ofrecen diferentes enfoques para el desarrollo de software. Mientras que la POO es un paradigma general con mecanismos para manejar asincron\u00eda, la PR se centra espec\u00edficamente en la gesti\u00f3n eficiente de flujos de datos as\u00edncronos.  La elecci\u00f3n del paradigma depende de las necesidades del proyecto.  Para aplicaciones con una alta complejidad as\u00edncrona, la PR ofrece una soluci\u00f3n m\u00e1s elegante y mantenible.  Sin embargo, para proyectos m\u00e1s simples, la POO puede ser suficiente.  En muchos casos, ambos paradigmas pueden coexistir y complementarse, aprovechando las fortalezas de cada uno.\n"}], "casosUso": [{"numero": 16, "descripcion": "**Caso 1**  \n- **Escenario**: Un sistema de reservas de vuelos debe manejar picos de tr\u00e1fico masivos durante temporadas vacacionales, garantizando disponibilidad y consistencia de datos.  \n- **Requisitos**: Implementa un servicio de reservas reactivo que utilice event sourcing para manejar cambios de estado y CQRS para separar consultas y comandos.  \n- **Herramientas**: Akka, Apache Kafka, Cassandra.  \n", "pregunta": "Desarrolle una soluci\u00f3n para el caso descrito anteriormente", "puntaje": 1, "respuestaAlumno": "", "archivoSubido": false, "respuestaProfesor": "## Soluci\u00f3n al Caso 1: Sistema de Reservas de Vuelos con Event Sourcing y CQRS\n\nEste dise\u00f1o propone una soluci\u00f3n reactiva para un sistema de reservas de vuelos utilizando Event Sourcing, CQRS, Akka, Apache Kafka y Cassandra, enfocada en manejar picos de tr\u00e1fico y garantizar la consistencia de datos.\n\n**Arquitectura:**\n\nLa arquitectura se basa en el patr\u00f3n CQRS, separando las operaciones de lectura (Queries) de las de escritura (Commands).  Utilizamos Event Sourcing para persistir los cambios de estado como una secuencia inmutable de eventos.\n\n**Componentes Principales:**\n\n* **Command Service:** Recibe las solicitudes de reserva (Commands), valida la informaci\u00f3n y genera un evento.\n* **Event Store (Kafka):**  Almacena los eventos de forma persistente y ordenada. Kafka proporciona alta disponibilidad y escalabilidad para manejar el alto volumen de eventos durante picos de tr\u00e1fico.\n* **Event Handlers (Akka Actors):**  Procesan los eventos del Event Store.  Existen diferentes tipos de Event Handlers:\n    * **Aggregate Handler:** Aplica los eventos al estado actual de la reserva (ej.,  `ReservaAgregada`).  Garantiza la consistencia del estado.\n    * **Projection Handler:** Crea y actualiza las vistas materializadas (read models) en Cassandra optimizadas para las consultas.  Por ejemplo, una vista para buscar vuelos disponibles.\n    * **Notification Handler:**  Env\u00eda notificaciones (ej., email de confirmaci\u00f3n) basadas en los eventos.\n* **Query Service:** Recibe las solicitudes de consulta (Queries) y las responde utilizando las vistas materializadas en Cassandra.  Cassandra ofrece bajo latency y alta disponibilidad para las lecturas.\n\n**Flujo de una Reserva:**\n\n1. **Solicitud de Reserva (Command):** El usuario solicita una reserva a trav\u00e9s de la interfaz de usuario. Esta solicitud se env\u00eda al Command Service.\n2. **Validaci\u00f3n y Generaci\u00f3n de Evento:** El Command Service valida la solicitud (ej., disponibilidad de asientos). Si la validaci\u00f3n es exitosa, genera un evento (ej., `ReservaCreada`).\n3. **Publicaci\u00f3n del Evento:** El evento se publica en el Event Store (Kafka).\n4. **Procesamiento del Evento:**\n    * **Aggregate Handler:**  El Aggregate Handler correspondiente a la reserva procesa el evento `ReservaCreada` y actualiza el estado interno de la reserva.\n    * **Projection Handler:**  El Projection Handler recibe el evento y actualiza la vista materializada de vuelos disponibles en Cassandra, decrementando el n\u00famero de asientos.\n    * **Notification Handler:**  El Notification Handler recibe el evento y env\u00eda un email de confirmaci\u00f3n al usuario.\n5. **Consulta de Disponibilidad (Query):**  El usuario puede consultar la disponibilidad de vuelos.  El Query Service consulta directamente la vista materializada en Cassandra, proporcionando una respuesta r\u00e1pida.\n\n\n**Ventajas de esta soluci\u00f3n:**\n\n* **Escalabilidad:**  Kafka y Cassandra permiten escalar horizontalmente para manejar picos de tr\u00e1fico.  Akka facilita la distribuci\u00f3n de la carga entre los actores.\n* **Consistencia de Datos:** Event Sourcing garantiza la consistencia del estado de las reservas mediante la secuencia inmutable de eventos.\n* **Rendimiento:**  CQRS permite optimizar las consultas y los comandos por separado. Cassandra proporciona un alto rendimiento para las lecturas.\n* **Auditabilidad:**  El Event Store proporciona un registro completo de todos los cambios de estado, facilitando la auditor\u00eda.\n* **Flexibilidad:**  La arquitectura permite a\u00f1adir nuevas funcionalidades f\u00e1cilmente mediante la creaci\u00f3n de nuevos Event Handlers y vistas materializadas.\n\n\n**Consideraciones adicionales:**\n\n* **Manejo de Idempotencia:**  Es importante manejar la idempotencia de los comandos para evitar la duplicaci\u00f3n de reservas en caso de reintentos.\n* **Versionado de Eventos:**  Se debe implementar un mecanismo de versionado de eventos para asegurar la compatibilidad hacia atr\u00e1s.\n* **Monitoreo:**  Es crucial monitorear el rendimiento del sistema, especialmente durante picos de tr\u00e1fico.\n\n\n**Conclusi\u00f3n:**\n\nEsta soluci\u00f3n proporciona una arquitectura robusta y escalable para un sistema de reservas de vuelos, utilizando Event Sourcing y CQRS para manejar picos de tr\u00e1fico y garantizar la consistencia de datos. La combinaci\u00f3n de Akka, Kafka y Cassandra ofrece las herramientas necesarias para implementar un sistema de alto rendimiento y disponibilidad.  El dise\u00f1o modular y la separaci\u00f3n de responsabilidades facilitan el mantenimiento y la evoluci\u00f3n del sistema a largo plazo.\n"}, {"numero": 17, "descripcion": "1. **Caso de Uso: Sistema de Reservas en Tiempo Real para un Cine**  \n   - **Escenario**: Un cine necesita un sistema que actualice en tiempo real la disponibilidad de asientos cuando los clientes realizan reservas desde m\u00faltiples dispositivos.  \n   - **Requisitos**: Implementar un backend reactivo que maneje concurrencia alta y garantice consistencia en los datos. El estudiante debe usar un enfoque de eventos para actualizar el estado de los asientos.  \n   - **Herramientas/Enfoques**: Akka (Actor Model), Spring WebFlux, bases de datos reactivas como MongoDB o Cassandra.  \n\n", "pregunta": "Desarrolle una soluci\u00f3n para el caso descrito anteriormente", "puntaje": 1, "respuestaAlumno": "", "archivoSubido": false, "respuestaProfesor": "## Soluci\u00f3n: Sistema de Reservas en Tiempo Real para un Cine\n\nEste documento describe una soluci\u00f3n para un sistema de reservas en tiempo real para un cine utilizando un backend reactivo con Akka, Spring WebFlux y MongoDB.  El enfoque se centra en la gesti\u00f3n de la concurrencia y la consistencia de datos mediante un sistema basado en eventos.\n\n**Arquitectura:**\n\nLa arquitectura propuesta se basa en los siguientes componentes:\n\n* **API REST con Spring WebFlux:**  Expone endpoints para que los clientes puedan consultar la disponibilidad de asientos y realizar reservas.\n* **Actores de Akka:** Gestionan el estado de las salas y los asientos. Cada sala de cine se representa mediante un actor, y cada asiento dentro de la sala tambi\u00e9n puede ser un actor (o el estado de los asientos puede gestionarse dentro del actor de la sala, dependiendo de la granularidad deseada).\n* **MongoDB:** Almacena la informaci\u00f3n de las pel\u00edculas, horarios, salas y la configuraci\u00f3n general del cine. Se utiliza como una base de datos eventualmente consistente para informaci\u00f3n que no requiere una consistencia estricta en tiempo real, como la cartelera.  El estado de las reservas se gestiona principalmente en memoria por los actores de Akka para un rendimiento \u00f3ptimo.\n* **Sistema de Eventos:**  Se utiliza para propagar los cambios en el estado de los asientos.  Cuando un asiento se reserva, se publica un evento. Otros componentes del sistema, como la API REST, pueden suscribirse a estos eventos para actualizar su estado en tiempo real.\n\n**Flujo de una Reserva:**\n\n1. **Solicitud del Cliente:** El cliente solicita la disponibilidad de asientos para una funci\u00f3n espec\u00edfica a trav\u00e9s de la API REST.\n2. **Consulta de Disponibilidad:** La API REST env\u00eda un mensaje al actor correspondiente a la sala de cine.\n3. **Respuesta del Actor:** El actor de la sala verifica el estado de los asientos y responde con la informaci\u00f3n de disponibilidad.\n4. **Solicitud de Reserva:** El cliente selecciona los asientos y env\u00eda una solicitud de reserva a la API REST.\n5. **Procesamiento de la Reserva:** La API REST env\u00eda un mensaje de reserva al actor de la sala.\n6. **Validaci\u00f3n y Actualizaci\u00f3n:** El actor de la sala valida la solicitud (verifica que los asientos sigan disponibles) y, si es v\u00e1lida, actualiza el estado de los asientos.\n7. **Publicaci\u00f3n del Evento:** El actor publica un evento indicando que los asientos se han reservado.\n8. **Notificaci\u00f3n:** La API REST, suscrita al evento, recibe la notificaci\u00f3n y actualiza su estado interno.  Tambi\u00e9n puede notificar al cliente sobre el \u00e9xito de la reserva.\n9. **Persistencia (opcional):**  El actor puede persistir el estado de la reserva en MongoDB de forma as\u00edncrona para tener un registro hist\u00f3rico y para la recuperaci\u00f3n en caso de fallos.  Esto no bloquea el flujo principal de la reserva.\n\n\n**Implementaci\u00f3n con Akka y Spring WebFlux:**\n\n```java\n// Ejemplo simplificado de un Actor de Sala\npublic class SalaActor extends AbstractActor {\n    private final Map<String, Boolean> asientos;\n\n    public SalaActor(int numAsientos) {\n        this.asientos = new HashMap<>();\n        for (int i = 1; i <= numAsientos; i++) {\n            asientos.put(\"A\" + i, false); // Inicialmente todos los asientos est\u00e1n libres\n        }\n    }\n\n    @Override\n    public Receive createReceive() {\n        return receiveBuilder()\n                .match(ConsultaDisponibilidad.class, msg -> {\n                    sender().tell(new Disponibilidad(asientos), self());\n                })\n                .match(ReservaAsientos.class, msg -> {\n                    if (msg.asientos.stream().allMatch(asiento -> asientos.getOrDefault(asiento, true) == false)) {\n                        msg.asientos.forEach(asiento -> asientos.put(asiento, true));\n                        getContext().getSystem().getEventStream().publish(new AsientosReservados(msg.asientos));\n                        sender().tell(new ReservaConfirmada(), self());\n                    } else {\n                        sender().tell(new ReservaRechazada(), self());\n                    }\n                })\n                .build();\n    }\n}\n\n// ... Mensajes, DTOs, y configuraci\u00f3n de Spring WebFlux ...\n```\n\n\n**Ventajas de este enfoque:**\n\n* **Concurrencia:** Akka maneja la concurrencia de forma eficiente, permitiendo que m\u00faltiples clientes realicen reservas simult\u00e1neamente sin problemas de consistencia.\n* **Escalabilidad:** El sistema puede escalar horizontalmente agregando m\u00e1s actores de sala.\n* **Resiliencia:**  El modelo de actores proporciona tolerancia a fallos.\n* **Tiempo Real:** El uso de eventos permite actualizaciones en tiempo real del estado de los asientos.\n\n\n**Consideraciones adicionales:**\n\n* **Manejo de errores:** Implementar un manejo adecuado de errores para gestionar situaciones como fallos de red o errores en la base de datos.\n* **Seguridad:** Implementar medidas de seguridad para proteger la informaci\u00f3n del cliente y prevenir accesos no autorizados.\n* **Pruebas:** Realizar pruebas exhaustivas para asegurar el correcto funcionamiento del sistema bajo diferentes escenarios de carga.\n* **Optimizaci\u00f3n del rendimiento:**  Considerar estrategias de caching y optimizaci\u00f3n de consultas para mejorar el rendimiento.\n\n\nEsta soluci\u00f3n proporciona una base s\u00f3lida para un sistema de reservas en tiempo real para un cine.  La combinaci\u00f3n de Akka, Spring WebFlux y una base de datos reactiva permite construir un sistema escalable, resiliente y con un alto rendimiento.  Recuerda que este es un ejemplo simplificado y debe ser adaptado a las necesidades espec\u00edficas del cine.\n"}]}, "createdAt": "2025-04-29T15:31:50.712039", "expiration": "2025-05-06T20:31:50.656Z", "publicAccess": true}