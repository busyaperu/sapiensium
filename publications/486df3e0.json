{"id": "486df3e0", "examenData": {"examen_id": "470771", "nombre_examen": "Programaci\u00f3n UML", "tipo_examen": "Evaluaci\u00f3n", "fecha": "2025-04-30T21:23:36.518Z", "nombre_profesor": "Mariela Isabel Camargo Rom\u00e1n", "profesor_id": "16MI987", "preguntas_marcar": [{"numero": 1, "texto": "\u00bfQu\u00e9 patr\u00f3n de dise\u00f1o se utiliza com\u00fanmente para manejar la retropresi\u00f3n en sistemas reactivos?", "puntaje": 1, "opciones": [{"texto": "Singleton", "valor": "A"}, {"texto": "Factory", "valor": "B"}, {"texto": "Circuit Breaker", "valor": "C"}, {"texto": "Observer", "valor": "D"}, {"texto": "Decorator", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 1}, {"numero": 2, "texto": "\u00bfCu\u00e1l es la principal ventaja de usar un sistema de mensajes asincr\u00f3nico en una arquitectura reactiva?", "puntaje": 1, "opciones": [{"texto": "Acoplamiento estrecho", "valor": "A"}, {"texto": "Mayor latencia", "valor": "B"}, {"texto": "Desacoplar componentes", "valor": "C"}, {"texto": "Complejidad reducida", "valor": "D"}, {"texto": "Mayor consumo de recursos", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 4}, {"numero": 3, "texto": "\u00bfQu\u00e9 tecnolog\u00eda se utiliza a menudo para implementar sistemas reactivos distribuidos?", "puntaje": 1, "opciones": [{"texto": "SOAP", "valor": "A"}, {"texto": "REST", "valor": "B"}, {"texto": "gRPC", "valor": "C"}, {"texto": "Akka", "valor": "D"}, {"texto": "CORBA", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 0}, {"numero": 4, "texto": "\u00bfQu\u00e9 concepto se refiere a la capacidad de un sistema reactivo para mantenerse responsivo bajo carga variable?", "puntaje": 1, "opciones": [{"texto": "Resiliencia", "valor": "A"}, {"texto": "Elasticidad", "valor": "B"}, {"texto": "Orientado a mensajes", "valor": "C"}, {"texto": "Aislamiento de fallos", "valor": "D"}, {"texto": "Retropresi\u00f3n", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 1}, {"numero": 5, "texto": "\u00bfCu\u00e1l de las siguientes NO es una caracter\u00edstica t\u00edpica de un sistema reactivo?", "puntaje": 1, "opciones": [{"texto": "Tolerancia a fallos", "valor": "A"}, {"texto": "Estado mutable compartido", "valor": "B"}, {"texto": "Retropresi\u00f3n", "valor": "C"}, {"texto": "No bloqueante", "valor": "D"}, {"texto": "Concurrencia", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 0}, {"numero": 6, "texto": "\u00bfQu\u00e9 patr\u00f3n de mensajer\u00eda describe un flujo continuo de datos entre un emisor y un receptor?", "puntaje": 1, "opciones": [{"texto": "Publish-Subscribe", "valor": "A"}, {"texto": "Request-Response", "valor": "B"}, {"texto": "Streaming", "valor": "C"}, {"texto": "Circuit Breaker", "valor": "D"}, {"texto": "Command Query Responsibility Segregation (CQRS)", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 1}, {"numero": 7, "texto": "En el contexto de sistemas reactivos, \u00bfqu\u00e9 significa \"backpressure\"?", "puntaje": 1, "opciones": [{"texto": "Un mecanismo para manejar errores", "valor": "A"}, {"texto": "Un m\u00e9todo para escalar sistemas", "valor": "B"}, {"texto": "Una forma de controlar el flujo de datos de un emisor a un receptor", "valor": "C"}, {"texto": "Un tipo de sistema de mensajer\u00eda", "valor": "D"}, {"texto": "Una t\u00e9cnica de optimizaci\u00f3n de rendimiento", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 1}, {"numero": 8, "texto": "\u00bfCu\u00e1l de las siguientes es una herramienta o biblioteca com\u00fanmente utilizada para construir sistemas reactivos?", "puntaje": 1, "opciones": [{"texto": "AngularJS", "valor": "A"}, {"texto": "ReactJS", "valor": "B"}, {"texto": "Vue.js", "valor": "C"}, {"texto": "RxJava", "valor": "D"}, {"texto": "jQuery", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 3}, {"numero": 9, "texto": "\u00bfQu\u00e9 principio de dise\u00f1o reactivo se centra en aislar los fallos para evitar que se propaguen por todo el sistema?", "puntaje": 1, "opciones": [{"texto": "Responsividad", "valor": "A"}, {"texto": "Resiliencia", "valor": "B"}, {"texto": "Elasticidad", "valor": "C"}, {"texto": "Orientado a mensajes", "valor": "D"}, {"texto": "Aislamiento de fallos", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 1}], "preguntas_libres": [{"numero": 10, "texto": "Describe c\u00f3mo el principio de \"aislamiento de fallos\" se implementa en una arquitectura reactiva y proporciona un ejemplo concreto de c\u00f3mo se maneja un fallo en un componente sin afectar a todo el sistema.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "## Aislamiento de Fallos en Arquitecturas Reactivas\n\nEl principio de \"aislamiento de fallos\" es crucial en arquitecturas reactivas para garantizar la resiliencia y la disponibilidad del sistema.  Se basa en la idea de contener los fallos dentro de un componente espec\u00edfico, evitando que se propaguen y afecten a otros componentes o a todo el sistema.  Esto se logra mediante la combinaci\u00f3n de varias t\u00e9cnicas y patrones de dise\u00f1o.\n\n**Mecanismos de Aislamiento de Fallos en Arquitecturas Reactivas:**\n\n1. **Componentes Aislados:**  La arquitectura reactiva promueve la descomposici\u00f3n del sistema en componentes peque\u00f1os, aut\u00f3nomos y d\u00e9bilmente acoplados.  Cada componente opera de forma independiente y se comunica con otros componentes a trav\u00e9s de mensajes as\u00edncronos. Este aislamiento inherente limita el impacto de un fallo en un solo componente.\n\n2. **Supervisores:**  Los supervisores son un componente esencial en la gesti\u00f3n de fallos.  Act\u00faan como \"guardianes\" de otros componentes (sus \"hijos\").  Si un componente hijo falla, el supervisor detecta el fallo y toma la acci\u00f3n apropiada, como reiniciar el componente, detenerlo o escalar el problema a un supervisor de nivel superior.  Este mecanismo contiene el fallo dentro del \u00e1rbol de supervisi\u00f3n, evitando su propagaci\u00f3n.\n\n3. **Bulkheads (Mamparos):**  Inspirado en la compartimentaci\u00f3n de los barcos, el patr\u00f3n Bulkhead divide el sistema en compartimentos aislados.  Si un compartimento se \"inunda\" (falla), los otros compartimentos permanecen operativos.  En una arquitectura reactiva, esto se puede implementar asignando recursos dedicados (ej. hilos, conexiones a bases de datos) a cada componente.  Un fallo en un componente no afectar\u00e1 los recursos de otros componentes, previniendo fallos en cascada.\n\n4. **Timeouts y Retries:**  Los timeouts previenen que un componente espere indefinidamente una respuesta de otro componente que podr\u00eda haber fallado.  Los retries permiten a un componente intentar de nuevo una operaci\u00f3n que fall\u00f3, lo que puede ser \u00fatil para manejar fallos transitorios.\n\n5. **Circuit Breaker (Disyuntor):**  El patr\u00f3n Circuit Breaker previene que un componente contin\u00fae realizando llamadas a un servicio que est\u00e1 fallando repetidamente.  Act\u00faa como un disyuntor el\u00e9ctrico, \"abriendo el circuito\" para evitar m\u00e1s llamadas al servicio fallido durante un per\u00edodo de tiempo.  Despu\u00e9s de un per\u00edodo de espera, el circuit breaker se \"cierra parcialmente\" para permitir algunas llamadas de prueba. Si estas llamadas tienen \u00e9xito, el circuito se \"cierra\" completamente; de lo contrario, se vuelve a \"abrir\".\n\n\n**Ejemplo Concreto:**\n\nImaginemos un sistema de comercio electr\u00f3nico reactivo con tres componentes: un servicio de cat\u00e1logo, un servicio de carrito de compras y un servicio de pago.  Si el servicio de pago falla, el sistema debe seguir funcionando.\n\n* **Aislamiento:** Los componentes se comunican a trav\u00e9s de mensajes as\u00edncronos. Un fallo en el servicio de pago no bloquea directamente al servicio de carrito de compras o al servicio de cat\u00e1logo.\n* **Supervisor:** Un supervisor monitorea el servicio de pago. Si este falla, el supervisor lo reinicia.\n* **Bulkhead:** Cada servicio tiene su propio pool de conexiones a la base de datos.  Un fallo en el servicio de pago no agota las conexiones de la base de datos de los otros servicios.\n* **Timeout y Retry:** El servicio de carrito de compras utiliza un timeout al llamar al servicio de pago. Si la llamada no se completa dentro del timeout, se devuelve un error al usuario.  Se pueden implementar retries para manejar fallos transitorios en el servicio de pago.\n* **Circuit Breaker:** El servicio de carrito de compras utiliza un circuit breaker para el servicio de pago. Si el servicio de pago falla repetidamente, el circuit breaker se abre, evitando que el servicio de carrito de compras realice m\u00e1s llamadas al servicio de pago durante un per\u00edodo de tiempo.  Esto protege al sistema de una avalancha de solicitudes fallidas al servicio de pago.\n\n\nEn resumen, el aislamiento de fallos en arquitecturas reactivas se logra mediante la combinaci\u00f3n de componentes aislados, supervisores, bulkheads, timeouts, retries y circuit breakers.  Estos mecanismos aseguran que un fallo en un componente se contenga y no afecte la disponibilidad y la resiliencia del sistema en su conjunto.  El ejemplo del sistema de comercio electr\u00f3nico ilustra c\u00f3mo estos principios se aplican en la pr\u00e1ctica para manejar fallos de forma robusta.\n"}, {"numero": 11, "texto": "Explica c\u00f3mo el backpressure contribuye a la resiliencia de un sistema reactivo. Describe diferentes estrategias para implementar backpressure y analiza sus ventajas e inconvenientes.", "puntaje": 2, "respuestaAlumno": "", "respuestaProfesor": "## Backpressure y Resiliencia en Sistemas Reactivos\n\nEn sistemas reactivos, el backpressure es un mecanismo esencial para la resiliencia, permitiendo que un sistema bajo presi\u00f3n se comunique con los productores de datos para regular el flujo de informaci\u00f3n.  En esencia, es la capacidad de un sistema sobrecargado de se\u00f1alizar a los componentes upstream que reduzcan la velocidad de env\u00edo de datos, evitando as\u00ed la sobrecarga y el colapso del sistema.  Sin backpressure, un sistema podr\u00eda verse abrumado por la entrada de datos, llevando a la p\u00e9rdida de datos, latencia excesiva y, en \u00faltima instancia, fallos.\n\n**\u00bfC\u00f3mo contribuye el backpressure a la resiliencia?**\n\nEl backpressure proporciona resiliencia de varias maneras:\n\n* **Prevenci\u00f3n de la sobrecarga:** Al regular el flujo de datos, el backpressure evita que los componentes downstream se saturen. Esto protege al sistema de fallos por agotamiento de recursos como memoria, CPU o conexiones de red.\n* **Manejo de la congesti\u00f3n:**  Cuando la demanda supera la capacidad de procesamiento, el backpressure act\u00faa como una v\u00e1lvula de escape, permitiendo que el sistema maneje la congesti\u00f3n de forma ordenada. En lugar de colapsar bajo presi\u00f3n, el sistema puede ralentizar el procesamiento y continuar funcionando, aunque con mayor latencia.\n* **Propagaci\u00f3n de la carga:** El backpressure propaga la informaci\u00f3n sobre la congesti\u00f3n a los componentes upstream. Esto permite a todo el sistema adaptarse a la carga actual. Por ejemplo, un productor de datos puede reducir la velocidad de generaci\u00f3n de datos o almacenar temporalmente los datos en un buffer hasta que el sistema downstream est\u00e9 listo para procesarlos.\n* **Mayor previsibilidad:**  Al controlar el flujo de datos, el backpressure hace que el comportamiento del sistema sea m\u00e1s predecible bajo presi\u00f3n.  Esto facilita la monitorizaci\u00f3n, la depuraci\u00f3n y la optimizaci\u00f3n del rendimiento.\n\n\n**Estrategias para implementar backpressure:**\n\nExisten diversas estrategias para implementar backpressure, cada una con sus ventajas e inconvenientes:\n\n1. **Buffering:** El componente downstream utiliza un buffer para almacenar datos temporalmente. Cuando el buffer se llena, se env\u00eda una se\u00f1al al componente upstream para que detenga el env\u00edo de datos.\n\n    * **Ventajas:** Simple de implementar.\n    * **Inconvenientes:**  Puede introducir latencia y consumir memoria. Si el buffer se desborda, se puede producir p\u00e9rdida de datos.\n\n2. **Control de flujo basado en el tama\u00f1o de la ventana:** El componente downstream define un tama\u00f1o de ventana que indica cu\u00e1ntos datos puede procesar. El componente upstream solo puede enviar datos dentro del l\u00edmite de la ventana.\n\n    * **Ventajas:**  M\u00e1s eficiente que el buffering, ya que evita la copia de datos.\n    * **Inconvenientes:**  Requiere una coordinaci\u00f3n m\u00e1s compleja entre los componentes.\n\n3. **Backpressure expl\u00edcito:** El componente downstream env\u00eda se\u00f1ales expl\u00edcitas al componente upstream para indicar su capacidad de procesamiento.  Estas se\u00f1ales pueden ser simples (por ejemplo, un booleano indicando si est\u00e1 listo para recibir datos) o m\u00e1s complejas (por ejemplo, un n\u00famero indicando cu\u00e1ntos datos puede procesar).\n\n    * **Ventajas:**  Permite un control m\u00e1s preciso del flujo de datos.\n    * **Inconvenientes:**  Puede ser m\u00e1s complejo de implementar que las otras estrategias.\n\n4. **Conjuntos de tokens:** Similar al control de flujo basado en ventanas, pero utiliza \"tokens\" para representar la capacidad de procesamiento. El componente upstream necesita adquirir un token antes de enviar datos.  El componente downstream libera tokens a medida que procesa datos.\n\n    * **Ventajas:**  Flexibilidad y control granular sobre el flujo de datos.\n    * **Inconvenientes:**  Mayor complejidad de implementaci\u00f3n.\n\n\n**Conclusi\u00f3n:**\n\nEl backpressure es fundamental para la resiliencia de los sistemas reactivos.  Permite a los sistemas manejar la congesti\u00f3n de forma elegante, evitando fallos y manteniendo la estabilidad.  La elecci\u00f3n de la estrategia de backpressure adecuada depende de las caracter\u00edsticas espec\u00edficas del sistema, como el volumen de datos, la latencia tolerable y la complejidad de implementaci\u00f3n.  Es crucial comprender las ventajas e inconvenientes de cada estrategia para tomar una decisi\u00f3n informada y construir sistemas robustos y escalables.\n"}, {"numero": 12, "texto": "Dise\u00f1a un escenario donde se necesite implementar un sistema reactivo distribuido. Describe los componentes clave y c\u00f3mo se comunicar\u00edan entre s\u00ed utilizando principios reactivos. Considera aspectos como la consistencia eventual y la tolerancia a fallos.", "puntaje": 2, "respuestaAlumno": "", "respuestaProfesor": "## Escenario: Plataforma de Monitoreo de Sensores IoT para Agricultura de Precisi\u00f3n\n\nImaginemos una plataforma de monitoreo para agricultura de precisi\u00f3n que recolecta datos de miles de sensores IoT desplegados en un campo.  Estos sensores miden variables como temperatura, humedad del suelo, luminosidad y niveles de nutrientes en tiempo real. La plataforma debe procesar estos datos para proporcionar informaci\u00f3n \u00fatil a los agricultores, como recomendaciones de riego, fertilizaci\u00f3n y detecci\u00f3n temprana de plagas.  Dado el volumen de datos, la necesidad de respuesta en tiempo real y la posibilidad de fallos en sensores o la red, un sistema reactivo distribuido es la arquitectura ideal.\n\n**Componentes Clave y Comunicaci\u00f3n Reactiva:**\n\n1. **Sensores IoT (Publishers):** Los sensores act\u00faan como *publishers*, enviando flujos de datos de manera continua a un **Message Broker**.  Utilizan un protocolo ligero como MQTT para la comunicaci\u00f3n, minimizando el consumo de energ\u00eda y el ancho de banda.\n\n2. **Message Broker (Intermediario):**  Un Message Broker distribuido como Kafka o RabbitMQ gestiona los flujos de datos provenientes de los sensores.  Su funci\u00f3n es desacoplar a los *publishers* de los *subscribers*, permitiendo la escalabilidad y la tolerancia a fallos.  Implementa un mecanismo de *publish-subscribe* donde los datos se organizan en *topics* (ej. \"temperatura\", \"humedad\").\n\n3. **Microservicios de Procesamiento (Subscribers):**  Diversos microservicios se suscriben a los *topics* relevantes del Message Broker.  Ejemplos de estos microservicios:\n\n    * **Servicio de Agregaci\u00f3n:**  Procesa los datos de temperatura y humedad para calcular promedios por zona del campo.\n    * **Servicio de Detecci\u00f3n de Anomal\u00edas:**  Analiza los datos en busca de patrones inusuales que indiquen posibles problemas (ej. plagas, enfermedades).\n    * **Servicio de Recomendaciones:**  Genera recomendaciones personalizadas de riego y fertilizaci\u00f3n bas\u00e1ndose en los datos procesados.\n\n    Estos microservicios se comunican entre s\u00ed de forma as\u00edncrona utilizando *mensajes*.  Por ejemplo, el Servicio de Agregaci\u00f3n, tras calcular los promedios, publica un mensaje con estos resultados a un nuevo *topic*.  El Servicio de Recomendaciones se suscribe a este *topic* para utilizar los promedios en sus c\u00e1lculos.\n\n4. **API Gateway:**  Proporciona una interfaz unificada para que los agricultores accedan a la informaci\u00f3n procesada a trav\u00e9s de aplicaciones web o m\u00f3viles.  El API Gateway se comunica con los microservicios de forma reactiva, utilizando patrones como *backpressure* para controlar la carga y evitar la sobrecarga del sistema.\n\n5. **Base de Datos Distribuida:**  Una base de datos NoSQL distribuida como Cassandra o MongoDB almacena los datos procesados y las recomendaciones.  La consistencia eventual se utiliza para garantizar la disponibilidad y la tolerancia a fallos.  Los microservicios interact\u00faan con la base de datos de forma as\u00edncrona.\n\n**Consistencia Eventual y Tolerancia a Fallos:**\n\n* **Consistencia Eventual:**  Dado que los datos se procesan y almacenan de forma distribuida, la consistencia eventual es fundamental.  No se garantiza que todos los nodos tengan la misma informaci\u00f3n al mismo tiempo, pero se converge hacia un estado consistente eventualmente.  Esto permite al sistema seguir funcionando incluso con fallos en algunos nodos.\n* **Tolerancia a Fallos:** La arquitectura reactiva distribuida proporciona tolerancia a fallos a trav\u00e9s de la replicaci\u00f3n de los microservicios y la distribuci\u00f3n de datos en el Message Broker y la base de datos.  Si un sensor, un microservicio o un nodo de la base de datos falla, el sistema puede continuar operando con los componentes restantes.  El Message Broker garantiza que los mensajes no se pierdan en caso de fallo de un subscriber.\n\n\n**Beneficios de la Arquitectura Reactiva Distribuida:**\n\n* **Escalabilidad:** El sistema puede escalar horizontalmente para manejar el creciente volumen de datos y las demandas de procesamiento.\n* **Resiliencia:** La tolerancia a fallos asegura la disponibilidad del sistema incluso con fallos en componentes individuales.\n* **Responsividad:** El procesamiento as\u00edncrono y la comunicaci\u00f3n no bloqueante permiten una respuesta r\u00e1pida a los eventos.\n* **Eficiencia:**  El uso de protocolos ligeros y la optimizaci\u00f3n del consumo de recursos mejoran la eficiencia del sistema.\n\n\nEste escenario demuestra c\u00f3mo un sistema reactivo distribuido puede ser utilizado para construir una plataforma robusta, escalable y resiliente para el monitoreo de sensores IoT en agricultura de precisi\u00f3n.  La comunicaci\u00f3n as\u00edncrona, la consistencia eventual y la tolerancia a fallos son principios clave que permiten al sistema manejar la complejidad y las demandas de este tipo de aplicaciones.\n"}, {"numero": 13, "texto": "Analiza las ventajas y desventajas de utilizar un framework reactivo en un proyecto de software. Considera factores como la complejidad del proyecto, la experiencia del equipo y los requisitos de rendimiento y escalabilidad.  \u00bfEn qu\u00e9 situaciones recomendar\u00edas *no* utilizar un framework reactivo y por qu\u00e9?", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "## An\u00e1lisis de las Ventajas y Desventajas de un Framework Reactivo\n\nLos frameworks reactivos, basados en el manifiesto reactivo, ofrecen un enfoque para el desarrollo de software que enfatiza la respuesta a eventos, la resiliencia, la elasticidad y la orientaci\u00f3n al mensaje. Si bien presentan ventajas significativas, tambi\u00e9n conllevan desventajas que deben considerarse cuidadosamente antes de su adopci\u00f3n.  La decisi\u00f3n de usar un framework reactivo debe basarse en una evaluaci\u00f3n exhaustiva de las necesidades del proyecto, la experiencia del equipo y las expectativas de rendimiento y escalabilidad.\n\n**Ventajas:**\n\n* **Mayor capacidad de respuesta y rendimiento:** Los frameworks reactivos permiten la creaci\u00f3n de aplicaciones altamente responsivas que manejan eficientemente flujos de datos as\u00edncronos. Esto se traduce en una mejor experiencia de usuario, especialmente en aplicaciones con actualizaciones frecuentes o interacciones en tiempo real.\n* **Escalabilidad mejorada:** La arquitectura reactiva facilita la escalabilidad horizontal al permitir la distribuci\u00f3n de la carga de trabajo entre m\u00faltiples nodos. Esto es crucial para aplicaciones que experimentan picos de tr\u00e1fico o requieren un alto rendimiento.\n* **Mayor resiliencia:**  Gracias a su dise\u00f1o modular y a la gesti\u00f3n de fallos integrada, las aplicaciones reactivas son m\u00e1s resistentes a errores y ca\u00eddas.  El aislamiento de fallos evita que un componente problem\u00e1tico afecte al sistema completo.\n* **Mayor mantenibilidad y testabilidad:** El c\u00f3digo reactivo suele ser m\u00e1s modular y f\u00e1cil de entender, lo que simplifica el mantenimiento y la depuraci\u00f3n.  Adem\u00e1s, la naturaleza as\u00edncrona del c\u00f3digo facilita la escritura de pruebas unitarias y de integraci\u00f3n.\n* **Simplificaci\u00f3n de la programaci\u00f3n as\u00edncrona:** Los frameworks reactivos proporcionan abstracciones y operadores que simplifican la gesti\u00f3n de operaciones as\u00edncronas, evitando el \"callback hell\" y haciendo el c\u00f3digo m\u00e1s legible y mantenible.\n\n\n**Desventajas:**\n\n* **Mayor complejidad inicial:** La curva de aprendizaje de los frameworks reactivos puede ser pronunciada, especialmente para equipos sin experiencia previa con programaci\u00f3n reactiva o funcional.  La depuraci\u00f3n y el seguimiento de errores tambi\u00e9n pueden ser m\u00e1s complejos al principio.\n* **Sobrecarga para proyectos simples:** En proyectos peque\u00f1os o con requisitos de rendimiento y escalabilidad modestos, la complejidad a\u00f1adida de un framework reactivo puede ser una sobrecarga innecesaria.  Un enfoque m\u00e1s tradicional podr\u00eda ser m\u00e1s eficiente en estos casos.\n* **Dependencia de bibliotecas y frameworks:**  Los frameworks reactivos introducen dependencias adicionales al proyecto, lo que puede aumentar el tama\u00f1o del c\u00f3digo y la complejidad de la gesti\u00f3n de dependencias.\n* **Dificultad para el debugging en sistemas distribuidos:** Si bien la resiliencia es una ventaja, la depuraci\u00f3n en un sistema reactivo distribuido puede ser compleja debido a la naturaleza as\u00edncrona y la propagaci\u00f3n de eventos.\n\n\n**\u00bfCu\u00e1ndo *NO* usar un framework reactivo?**\n\n* **Proyectos peque\u00f1os y simples:** Si la aplicaci\u00f3n es simple y no requiere un alto rendimiento ni escalabilidad, un framework reactivo a\u00f1adir\u00e1 complejidad innecesaria.\n* **Equipo sin experiencia:** Si el equipo de desarrollo no tiene experiencia con programaci\u00f3n reactiva, el tiempo de aprendizaje y la probabilidad de errores pueden ser significativos, impactando negativamente el cronograma y el presupuesto del proyecto.\n* **Aplicaciones con requisitos de rendimiento predecibles y bajos:** Si la aplicaci\u00f3n no necesita manejar picos de tr\u00e1fico o un alto volumen de datos, un framework reactivo no ofrecer\u00e1 beneficios significativos.\n* **Cuando la depuraci\u00f3n en tiempo real es cr\u00edtica:**  Si la aplicaci\u00f3n requiere una depuraci\u00f3n en tiempo real muy precisa, la complejidad de un sistema reactivo distribuido puede dificultar el proceso.\n\n\n**Conclusi\u00f3n:**\n\nLa decisi\u00f3n de utilizar un framework reactivo debe ser tomada con cuidado, considerando las ventajas y desventajas en relaci\u00f3n con las necesidades espec\u00edficas del proyecto.  Si bien ofrecen beneficios significativos en t\u00e9rminos de rendimiento, escalabilidad y resiliencia, tambi\u00e9n introducen complejidad que puede ser contraproducente en ciertos escenarios.  Una evaluaci\u00f3n exhaustiva de la complejidad del proyecto, la experiencia del equipo y los requisitos de rendimiento y escalabilidad es esencial para tomar la decisi\u00f3n correcta.\n"}], "casos_uso": [{"numero": 14, "descripcion": "1.\n   - Escenario pr\u00e1ctico detallado: Una plataforma de trading financiero en tiempo real que recibe flujos constantes de datos de mercado (precios, volumen) de m\u00faltiples fuentes, procesa \u00f3rdenes de compra/venta a muy alta velocidad y debe notificar a los usuarios sobre cambios relevantes en sus posiciones o el mercado con m\u00ednima latencia. La estabilidad y la capacidad de manejar picos de datos son cr\u00edticas.\n   - Requisitos espec\u00edficos: Analizar el escenario y generar dos preguntas pr\u00e1cticas sobre c\u00f3mo una arquitectura reactiva podr\u00eda abordar desaf\u00edos espec\u00edficos del trading en tiempo real, centr\u00e1ndose cada pregunta en un caso de uso reactivo distinto dentro de este contexto (ej. manejo eficiente de streams de datos de mercado, aplicaci\u00f3n de backpressure en el procesamiento de \u00f3rdenes).\n   - Sugerencias de herramientas o enfoques: Considerar conceptos como streams de datos reactivos, manejo de backpressure, tolerancia a fallos, concurrencia as\u00edncrona. Herramientas: Kafka, Akka, Spring WebFlux, Project Reactor, RxJava.\n\n", "pregunta": "Desarrolle una soluci\u00f3n para el caso descrito anteriormente", "puntaje": 5, "respuestaAlumno": "", "archivoSubido": false, "respuestaProfesor": "## Soluciones para los 5 Casos de Uso de Arquitecturas Reactivas\n\nA continuaci\u00f3n, se presentan dos preguntas y sus respectivas respuestas para cada uno de los cinco escenarios planteados, explorando c\u00f3mo las arquitecturas reactivas pueden abordar los desaf\u00edos espec\u00edficos de cada caso.\n\n**1. Plataforma de Trading Financiero en Tiempo Real**\n\n* **Pregunta 1:** \u00bfC\u00f3mo se puede utilizar un stream de datos reactivo para procesar eficientemente los flujos constantes de datos de mercado (precios, volumen) provenientes de m\u00faltiples fuentes, garantizando la m\u00ednima latencia en la actualizaci\u00f3n de informaci\u00f3n para los usuarios?\n\n* **Respuesta 1:**  Utilizando herramientas como Kafka o Apache Pulsar para la ingesta y distribuci\u00f3n de datos de mercado.  Estos act\u00faan como un bus de mensajes distribuido y tolerante a fallos.  Un stream reactivo, implementado con Project Reactor o RxJava, puede suscribirse a los topics de Kafka correspondientes a cada fuente de datos.  Las operaciones de transformaci\u00f3n y enriquecimiento de datos (ej. calcular medias m\u00f3viles, aplicar filtros) se realizan sobre el stream de forma as\u00edncrona y no bloqueante.  Finalmente, el stream actualizado se utiliza para notificar a los usuarios en tiempo real a trav\u00e9s de WebSockets, minimizando la latencia.  La naturaleza as\u00edncrona y la capacidad de paralelizar el procesamiento del stream permiten manejar el alto volumen y velocidad de los datos de mercado.\n\n* **Pregunta 2:** \u00bfC\u00f3mo se puede aplicar backpressure en el procesamiento de \u00f3rdenes de compra/venta para evitar la sobrecarga del sistema durante picos de actividad, manteniendo la responsividad de la plataforma?\n\n* **Respuesta 2:**  Implementando un mecanismo de backpressure utilizando Project Reactor o RxJava.  Cuando el sistema de procesamiento de \u00f3rdenes (ej. un servicio de matching de \u00f3rdenes) se acerca a su capacidad m\u00e1xima, puede comunicar esta situaci\u00f3n aguas arriba en el stream de \u00f3rdenes.  Esto se puede lograr utilizando operadores como `onBackpressureBuffer`, `onBackpressureDrop` o `onBackpressureLatest`.  De esta manera, la fuente de \u00f3rdenes (ej. la interfaz de usuario) puede ajustar la tasa de env\u00edo de nuevas \u00f3rdenes, evitando la saturaci\u00f3n del sistema y manteniendo su estabilidad.  La plataforma podr\u00eda, por ejemplo, limitar la frecuencia con la que los usuarios pueden enviar \u00f3rdenes o mostrar un mensaje de alerta indicando la alta carga del sistema.\n\n\n**2. Sistema de Monitoreo de Dispositivos IoT**\n\n* **Pregunta 1:** \u00bfC\u00f3mo se puede lograr la escalabilidad horizontal en la ingesta de datos de telemetr\u00eda provenientes de millones de sensores IoT distribuidos?\n\n* **Respuesta 1:**  Utilizando un cluster de Kafka para la ingesta de datos. Los sensores IoT publican datos en topics espec\u00edficos de Kafka. La escalabilidad horizontal se logra a\u00f1adiendo m\u00e1s brokers a este cl\u00faster.  Herramientas como Apache NiFi pueden utilizarse para la recolecci\u00f3n y pre-procesamiento de datos antes de enviarlos a Kafka, gestionando la heterogeneidad de los dispositivos y protocolos de comunicaci\u00f3n.  Esta arquitectura distribuida permite manejar el volumen masivo de datos y la variabilidad en la tasa de datos provenientes de los sensores.\n\n* **Pregunta 2:** \u00bfC\u00f3mo se puede utilizar el procesamiento de streams de eventos para la detecci\u00f3n de anomal\u00edas en tiempo real en los datos de telemetr\u00eda?\n\n* **Respuesta 2:**  Empleando Apache Flink o Kafka Streams.  Estos frameworks permiten procesar streams de datos en tiempo real, aplicando funciones de agregaci\u00f3n, filtrado y an\u00e1lisis a los datos de telemetr\u00eda provenientes de Kafka.  Se pueden definir ventanas de tiempo para analizar los datos y detectar anomal\u00edas basadas en reglas predefinidas o modelos de machine learning.  Por ejemplo, se puede calcular la media m\u00f3vil de la temperatura en una ventana de tiempo y generar una alerta si se supera un umbral determinado.  La detecci\u00f3n de anomal\u00edas en tiempo real permite tomar acciones correctivas de forma inmediata.\n\n\n**3. Backend de Juego Multijugador Online**\n\n* **Pregunta 1:** \u00bfC\u00f3mo se pueden utilizar streams reactivos para sincronizar el estado del juego en tiempo real entre miles de jugadores concurrentes, minimizando la latencia?\n\n* **Respuesta 1:**  Utilizando una combinaci\u00f3n de Akka y WebSockets. Akka Actors pueden representar a cada jugador y al estado del juego.  Los cambios en el estado del juego se propagan a trav\u00e9s de mensajes entre los actores.  WebSockets permiten la comunicaci\u00f3n bidireccional en tiempo real entre el servidor y los clientes (jugadores).  Los cambios en el estado del juego se env\u00edan a los clientes a trav\u00e9s de WebSockets, asegurando la sincronizaci\u00f3n en tiempo real con m\u00ednima latencia.\n\n* **Pregunta 2:** \u00bfC\u00f3mo se puede manejar de forma resiliente la conexi\u00f3n y desconexi\u00f3n de jugadores, as\u00ed como fallos de red, sin afectar la experiencia de juego de los dem\u00e1s participantes?\n\n* **Respuesta 2:**  Utilizando la supervisi\u00f3n de actores en Akka.  Cada jugador puede ser representado por un actor hijo supervisado por un actor padre.  Si un jugador se desconecta o ocurre un fallo de red, el actor hijo correspondiente termina, pero el actor padre puede reiniciarlo o tomar las acciones necesarias para mantener la consistencia del juego.  Esto permite manejar fallos de forma aislada sin afectar a otros jugadores.  El uso de un backend distribuido con Akka Cluster tambi\u00e9n proporciona tolerancia a fallos a nivel de nodos.\n\n\n**4. Plataforma de E-commerce de Alto Tr\u00e1fico**\n\n* **Pregunta 1:** \u00bfC\u00f3mo se puede implementar el procesamiento as\u00edncrono y resiliente de pedidos durante picos de demanda como el Black Friday?\n\n* **Respuesta 1:**  Utilizando colas de mensajes como Kafka o RabbitMQ.  Los pedidos se env\u00edan a una cola de mensajes para su procesamiento as\u00edncrono.  M\u00faltiples instancias de un servicio de procesamiento de pedidos consumen mensajes de la cola, permitiendo la escalabilidad horizontal.  Si un servicio falla, el mensaje permanece en la cola hasta que otro servicio lo procese, garantizando la resiliencia.\n\n* **Pregunta 2:** \u00bfC\u00f3mo se puede aplicar backpressure al interactuar con pasarelas de pago externas para evitar su sobrecarga durante picos de tr\u00e1fico?\n\n* **Respuesta 2:**  Utilizando el patr\u00f3n Circuit Breaker en conjunto con colas de mensajes.  El Circuit Breaker monitoriza la disponibilidad de la pasarela de pago.  Si la pasarela se sobrecarga o falla, el Circuit Breaker se abre, y los nuevos pedidos se acumulan en una cola de mensajes.  Una vez que la pasarela se recupera, el Circuit Breaker se cierra, y los pedidos en la cola se procesan.  Esto evita la cascada de fallos y protege la pasarela de pago de la sobrecarga.\n\n\n**5. Agregaci\u00f3n de Feeds de Redes Sociales y Notificaciones Push**\n\n* **Pregunta 1:** \u00bfC\u00f3mo se puede implementar el consumo y transformaci\u00f3n continua de streams de datos de m\u00faltiples APIs de redes sociales?\n\n* **Respuesta 1:**  Utilizando Apache NiFi o StreamSets para la ingesta y procesamiento de datos de las APIs.  Estos frameworks permiten definir pipelines de datos que consumen datos de diferentes fuentes (APIs de redes sociales), aplican transformaciones (filtrado, agregaci\u00f3n) y env\u00edan los datos procesados a un sistema de mensajer\u00eda como Kafka.  La naturaleza distribuida de estas herramientas permite la escalabilidad y la tolerancia a fallos.\n\n* **Pregunta 2:** \u00bfC\u00f3mo se puede manejar la alta concurrencia y aplicar backpressure en el env\u00edo de notificaciones push a millones de dispositivos m\u00f3viles?\n\n* **Respuesta 2:**  Utilizando un sistema de colas de mensajes como Kafka o Pulsar en conjunto con un servicio de notificaciones push escalable.  Las notificaciones se env\u00edan a la cola de mensajes.  El servicio de notificaciones consume mensajes de la cola y env\u00eda las notificaciones a los dispositivos m\u00f3viles.  El backpressure se puede aplicar limitando la tasa de consumo de mensajes del servicio de notificaciones, evitando la sobrecarga del servicio y garantizando la entrega de notificaciones de forma eficiente.  La escalabilidad se logra a\u00f1adiendo m\u00e1s instancias del servicio de notificaciones.\n\n\nEsta soluci\u00f3n proporciona una base s\u00f3lida para comprender c\u00f3mo aplicar los principios reactivos en diferentes escenarios. Recuerda que la elecci\u00f3n de herramientas y la implementaci\u00f3n espec\u00edfica depender\u00e1n de los requisitos de cada proyecto.  Es fundamental comprender los conceptos clave como la asincron\u00eda, la no-bloqueo, la resiliencia y la backpressure para dise\u00f1ar sistemas reactivos eficientes y robustos.\n"}]}, "createdAt": "2025-04-30T16:23:36.631986", "expiration": "2025-05-07T21:23:36.518Z", "publicAccess": true}