{"id": "f97f11b3", "examenData": {"email": "smartlabelperu@gmail.com", "examen_id": "818595", "nombre_examen": "Principios SOLID de dise\u00f1o orientado a objetos", "tipo_examen": "Evaluaci\u00f3n", "fecha": "2025-06-25T16:04:20.506Z", "nombre_profesor": "Mariela Isabel Camargo Rom\u00e1n", "profesor_id": "16MI765", "preguntas_marcar": [{"numero": 1, "texto": "El principio de Abierto/Cerrado promueve que las clases deben estar:", "puntaje": 0.5, "opciones": [{"texto": "Abiertas a la modificaci\u00f3n y cerradas a la extensi\u00f3n", "valor": "A"}, {"texto": "Cerradas a la modificaci\u00f3n y abiertas a la extensi\u00f3n", "valor": "B"}, {"texto": "Abiertas tanto a la modificaci\u00f3n como a la extensi\u00f3n", "valor": "C"}, {"texto": "Cerradas tanto a la modificaci\u00f3n como a la extensi\u00f3n", "valor": "D"}, {"texto": "Ninguna de las anteriores", "valor": "E"}], "respuestaSeleccionada": null}, {"numero": 2, "texto": "\u00bfQu\u00e9 principio SOLID busca evitar la modificaci\u00f3n de clases existentes para a\u00f1adir nuevas funcionalidades?", "puntaje": 0.5, "opciones": [{"texto": "Principio de Responsabilidad \u00danica", "valor": "A"}, {"texto": "Principio de Abierto/Cerrado", "valor": "B"}, {"texto": "Principio de Sustituci\u00f3n de Liskov", "valor": "C"}, {"texto": "Principio de Inversi\u00f3n de Dependencias", "valor": "D"}, {"texto": "Principio de Segregaci\u00f3n de Interfaces", "valor": "E"}], "respuestaSeleccionada": null}, {"numero": 3, "texto": "\u00bfCu\u00e1l principio SOLID se viola cuando una subclase cambia el comportamiento de la clase padre de una manera inesperada?", "puntaje": 1, "opciones": [{"texto": "Principio de Responsabilidad \u00danica", "valor": "A"}, {"texto": "Principio de Abierto/Cerrado", "valor": "B"}, {"texto": "Principio de Sustituci\u00f3n de Liskov", "valor": "C"}, {"texto": "Principio de Inversi\u00f3n de Dependencias", "valor": "D"}, {"texto": "Principio de Segregaci\u00f3n de Interfaces", "valor": "E"}], "respuestaSeleccionada": null}, {"numero": 4, "texto": "El principio de Segregaci\u00f3n de Interfaces sugiere:", "puntaje": 0.5, "opciones": [{"texto": "Crear interfaces grandes y completas", "valor": "A"}, {"texto": "Evitar la creaci\u00f3n de interfaces", "valor": "B"}, {"texto": "Dividir interfaces grandes en interfaces m\u00e1s peque\u00f1as y espec\u00edficas", "valor": "C"}, {"texto": "Usar una \u00fanica interfaz para todas las clases", "valor": "D"}, {"texto": "Ninguna de las anteriores", "valor": "E"}], "respuestaSeleccionada": null}, {"numero": 5, "texto": "\u00bfQu\u00e9 principio SOLID promueve que una clase debe tener solo una raz\u00f3n para cambiar?", "puntaje": 0.5, "opciones": [{"texto": "Principio de Responsabilidad \u00danica", "valor": "A"}, {"texto": "Principio de Abierto/Cerrado", "valor": "B"}, {"texto": "Principio de Sustituci\u00f3n de Liskov", "valor": "C"}, {"texto": "Principio de Inversi\u00f3n de Dependencias", "valor": "D"}, {"texto": "Principio de Segregaci\u00f3n de Interfaces", "valor": "E"}], "respuestaSeleccionada": null}, {"numero": 6, "texto": "Si una clase depende de detalles concretos de otra clase, \u00bfqu\u00e9 principio SOLID se est\u00e1 violando probablemente?", "puntaje": 0.5, "opciones": [{"texto": "Principio de Responsabilidad \u00danica", "valor": "A"}, {"texto": "Principio de Abierto/Cerrado", "valor": "B"}, {"texto": "Principio de Sustituci\u00f3n de Liskov", "valor": "C"}, {"texto": "Principio de Inversi\u00f3n de Dependencias", "valor": "D"}, {"texto": "Principio de Segregaci\u00f3n de Interfaces", "valor": "E"}], "respuestaSeleccionada": null}, {"numero": 7, "texto": "\u00bfCu\u00e1l de estos principios SOLID se relaciona con la cohesi\u00f3n de una clase?", "puntaje": 0.5, "opciones": [{"texto": "Principio de Responsabilidad \u00danica", "valor": "A"}, {"texto": "Principio de Abierto/Cerrado", "valor": "B"}, {"texto": "Principio de Sustituci\u00f3n de Liskov", "valor": "C"}, {"texto": "Principio de Inversi\u00f3n de Dependencias", "valor": "D"}, {"texto": "Principio de Segregaci\u00f3n de Interfaces", "valor": "E"}], "respuestaSeleccionada": null}, {"numero": 8, "texto": "\u00bfQu\u00e9 principio SOLID busca reducir las dependencias entre m\u00f3dulos de alto y bajo nivel?", "puntaje": 0.5, "opciones": [{"texto": "Principio de Responsabilidad \u00danica", "valor": "A"}, {"texto": "Principio de Abierto/Cerrado", "valor": "B"}, {"texto": "Principio de Sustituci\u00f3n de Liskov", "valor": "C"}, {"texto": "Principio de Inversi\u00f3n de Dependencias", "valor": "D"}, {"texto": "Principio de Segregaci\u00f3n de Interfaces", "valor": "E"}], "respuestaSeleccionada": null}, {"numero": 9, "texto": "\u00bfCu\u00e1l es el objetivo principal de aplicar los principios SOLID?", "puntaje": 0.5, "opciones": [{"texto": "Reducir la complejidad del c\u00f3digo y facilitar el mantenimiento", "valor": "A"}, {"texto": "Aumentar la velocidad de ejecuci\u00f3n del c\u00f3digo", "valor": "B"}, {"texto": "Disminuir el uso de memoria", "valor": "C"}, {"texto": "Mejorar la est\u00e9tica del c\u00f3digo", "valor": "D"}, {"texto": "Ninguna de las anteriores", "valor": "E"}], "respuestaSeleccionada": null}], "preguntas_libres": [{"numero": 10, "texto": "Explica el Principio de Responsabilidad \u00danica (SRP) y c\u00f3mo su violaci\u00f3n puede llevar a clases complejas y dif\u00edciles de mantener. Proporciona un ejemplo concreto de c\u00f3digo (puede ser pseudoc\u00f3digo) donde se viola este principio y describe c\u00f3mo lo refactorizar\u00edas para cumplirlo.", "puntaje": 1.5, "respuestaAlumno": ""}, {"numero": 11, "texto": "Describe el Principio de Abierto/Cerrado (OCP) y explica por qu\u00e9 es crucial para la extensibilidad del software. \u00bfQu\u00e9 patrones de dise\u00f1o se utilizan com\u00fanmente para adherirse a este principio y c\u00f3mo funcionan?", "puntaje": 1.5, "respuestaAlumno": ""}, {"numero": 12, "texto": "\u00bfQu\u00e9 es el Principio de Sustituci\u00f3n de Liskov (LSP)? Explica con un ejemplo espec\u00edfico c\u00f3mo una violaci\u00f3n de este principio puede causar comportamientos inesperados en tiempo de ejecuci\u00f3n y qu\u00e9 implicaciones tiene para la herencia.", "puntaje": 1.5, "respuestaAlumno": ""}, {"numero": 13, "texto": "Define el Principio de Segregaci\u00f3n de la Interfaz (ISP). \u00bfPor qu\u00e9 es preferible tener muchas interfaces espec\u00edficas para los clientes en lugar de una interfaz general? Explica los beneficios de ISP en t\u00e9rminos de cohesi\u00f3n y acoplamiento.", "puntaje": 1.5, "respuestaAlumno": ""}, {"numero": 14, "texto": "Explica el Principio de Inversi\u00f3n de Dependencia (DIP). Describe c\u00f3mo la abstracci\u00f3n y la inversi\u00f3n del control ayudan a reducir el acoplamiento entre m\u00f3dulos. \u00bfQu\u00e9 son las dependencias de alto nivel y bajo nivel en el contexto de DIP?", "puntaje": 1.5, "respuestaAlumno": ""}], "casos_uso": [{"numero": 15, "descripcion": "**Caso 1**  \n**Escenario:** Un equipo desarrolla un sistema de procesamiento de pagos que debe soportar m\u00faltiples m\u00e9todos (tarjeta, transferencia, criptomonedas). Cada m\u00e9todo tiene reglas de validaci\u00f3n y ejecuci\u00f3n distintas.  \n**Requisitos:**  \n1. Aplicar el **Principio de Responsabilidad \u00danica (SRP)** para separar la l\u00f3gica de validaci\u00f3n y ejecuci\u00f3n de cada m\u00e9todo de pago.  \n2. Usar el **Principio de Abierto/Cerrado (OCP)** para permitir a\u00f1adir nuevos m\u00e9todos sin modificar el c\u00f3digo existente.  \n**Herramientas:** Patr\u00f3n Strategy, interfaces en Java o C#.  \n\n", "pregunta": "**  \n1. Aplicar el **Principio de Responsabilidad \u00danica (SRP)** para separar la l\u00f3gica de validaci\u00f3n y ejecuci\u00f3n de cada m\u00e9todo de pago.  \n2. Usar el **Principio de Abierto/Cerrado (OCP)** para permitir a\u00f1adir nuevos m\u00e9todos sin modificar el c\u00f3digo existente.  \n**Herramientas:** Patr\u00f3n Strategy, interfaces en Java o C#.  ", "puntaje": 4, "respuestaAlumno": "", "archivoSubido": false}, {"numero": 16, "descripcion": "**Escenario:** Sistema de gesti\u00f3n de empleados en una empresa con diferentes tipos de empleados (asalariados, por hora, comisionistas).\n    **Requisitos:** Implementar el principio de Sustituci\u00f3n de Liskov (LSP) asegurando que cualquier subclase de `Empleado` pueda ser usada en lugar de la clase base sin alterar la correcci\u00f3n del programa. Pregunta 1: \u00bfC\u00f3mo se implementar\u00eda la clase abstracta `Empleado` y sus subclases para cumplir con LSP al calcular el salario? Pregunta 2: \u00bfQu\u00e9 pruebas unitarias se podr\u00edan escribir para verificar el cumplimiento de LSP en este contexto?\n    **Sugerencias:** Usar herencia y polimorfismo.", "pregunta": "Desarrolle una soluci\u00f3n para el caso descrito anteriormente", "puntaje": 3.5, "respuestaAlumno": "", "archivoSubido": false}]}, "createdAt": "2025-06-25T11:04:20.584190", "expiration": "2025-07-02T16:04:20.506Z", "publicAccess": true}