{"id": "90a6d72a", "examenData": {"examen_id": "278546", "nombre_examen": "Arquitecturas Reactivas", "tipo_examen": "Evaluaci\u00f3n", "fecha": "2025-05-31T22:17:59.579Z", "nombre_profesor": "Mariela Isabel Camargo Rom\u00e1n", "profesor_id": "16MI987", "preguntas_marcar": [{"numero": 1, "texto": "\u00bfQu\u00e9 patr\u00f3n de dise\u00f1o es fundamental para la gesti\u00f3n de errores en un sistema reactivo?\nA) Singleton\nB) Factory\nC) Circuit Breaker\nD) Observer\nE) Strategy", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 1}, {"numero": 2, "texto": "\u00bfCu\u00e1l tecnolog\u00eda es ampliamente utilizada para implementar flujos de datos reactivos?\nA) JDBC\nB)  Spring MVC\nC)  Reactive Streams\nD)  Hibernate\nE)  JSP", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 0}, {"numero": 3, "texto": "\u00bfQu\u00e9 caracter\u00edstica describe mejor la elasticidad en una arquitectura reactiva?\nA) Capacidad de manejar picos de carga\nB)  Alta disponibilidad\nC)  Tolerancia a fallos\nD)  Respuesta r\u00e1pida a eventos\nE)  Escalabilidad vertical", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 4}, {"numero": 4, "texto": "\u00bfCu\u00e1l es la principal ventaja de utilizar un backpressure en un sistema reactivo?\nA)  Mejor rendimiento en bases de datos\nB)  Aumento de la latencia\nC)  Prevenci\u00f3n de sobrecarga del sistema\nD)  Reducci\u00f3n del consumo de memoria\nE)  Mayor complejidad de implementaci\u00f3n", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 1}, {"numero": 5, "texto": "\u00bfQu\u00e9 concepto se refiere a la capacidad de un sistema reactivo para continuar funcionando a pesar de fallos?\nA)  Escalabilidad\nB)  Elasticidad\nC)  Resiliencia\nD)  Responsividad\nE)  Modularidad", "puntaje": 1, "opciones": [{"texto": "Opci\u00f3n A", "valor": "A"}, {"texto": "Opci\u00f3n B", "valor": "B"}, {"texto": "Opci\u00f3n C", "valor": "C"}, {"texto": "Opci\u00f3n D", "valor": "D"}, {"texto": "Opci\u00f3n E", "valor": "E"}], "respuestaSeleccionada": null, "respuestaCorrectaIndex": 4}], "preguntas_libres": [{"numero": 6, "texto": "Explique c\u00f3mo la programaci\u00f3n reactiva y el patr\u00f3n de dise\u00f1o \"Command Query Responsibility Segregation\" (CQRS) pueden complementarse para mejorar la escalabilidad y el rendimiento de una aplicaci\u00f3n distribuida.", "puntaje": 1, "respuestaAlumno": "", "archivoId": "anexo_284879_1748470036329", "archivoNombre": "Diagrama sin t\u00edtulo.drawio.pdf", "archivoUrl": "https://cloud.appwrite.io/v1/storage/buckets/APPWRITE_BUCKET_DOCUMENTO_ANEXO_EXAMEN/files/anexo_284879_1748470036329/view?project=67e565df00172171560", "archivoTama\u00f1o": 2352, "archivoTipo": "application/pdf", "respuestaProfesor": "La programaci\u00f3n reactiva y CQRS se complementan para construir aplicaciones distribuidas escalables y de alto rendimiento.  La programaci\u00f3n reactiva, basada en flujos de datos as\u00edncronos, gestiona eficientemente las actualizaciones en tiempo real, mientras que CQRS separa las operaciones de lectura (Queries) y escritura (Commands) del modelo de datos.  Esta separaci\u00f3n permite optimizar cada ruta de forma independiente.  Por ejemplo, las consultas, a menudo m\u00e1s frecuentes, pueden escalarse horizontalmente utilizando cach\u00e9s distribuidas y bases de datos de lectura optimizadas.  Los comandos, que requieren consistencia, pueden implementarse con un enfoque orientado a eventos y mecanismos de concurrencia optimizados.  Al combinar ambos patrones, se logra una mayor  reactividad,  escalabilidad y tolerancia a fallos, ya que las operaciones de lectura no bloquean las de escritura y viceversa, facilitando la gesti\u00f3n de la complejidad inherente a los sistemas distribuidos.  Adem\u00e1s, la naturaleza as\u00edncrona de la programaci\u00f3n reactiva se alinea perfectamente con el procesamiento de eventos t\u00edpico de CQRS, simplificando la implementaci\u00f3n y mejorando la eficiencia.\n"}, {"numero": 7, "texto": "Analice la importancia del manejo de errores y la resiliencia en un sistema distribuido basado en arquitecturas reactivas.  \u00bfQu\u00e9 estrategias se pueden implementar para garantizar la tolerancia a fallos y la recuperaci\u00f3n ante situaciones inesperadas?", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "En sistemas distribuidos reactivos, el manejo de errores y la resiliencia son cruciales para mantener la disponibilidad y la consistencia.  Dado que estos sistemas operan en entornos complejos y propensos a fallos, es esencial dise\u00f1ar mecanismos que permitan al sistema tolerar fallos individuales sin afectar el funcionamiento global.  \n\nLa resiliencia se logra mediante la implementaci\u00f3n de estrategias como la replicaci\u00f3n de datos, el aislamiento de fallos mediante *bulkheads* y *circuit breakers*, y la supervisi\u00f3n continua del estado del sistema. La replicaci\u00f3n asegura la disponibilidad de la informaci\u00f3n incluso si un nodo falla.  Los *bulkheads* limitan el impacto de un fallo a una secci\u00f3n espec\u00edfica del sistema, mientras que los *circuit breakers* previenen la cascada de fallos al interrumpir la comunicaci\u00f3n con un servicio problem\u00e1tico.  Finalmente, la supervisi\u00f3n permite detectar y reaccionar a problemas r\u00e1pidamente.  Estas estrategias, combinadas con un dise\u00f1o basado en mensajes as\u00edncronos, contribuyen a la construcci\u00f3n de sistemas robustos y capaces de recuperarse ante situaciones inesperadas.\n"}, {"numero": 8, "texto": "Compare y contraste dos frameworks o librer\u00edas populares para la implementaci\u00f3n de arquitecturas reactivas (ej: Spring Reactor, Akka).  Discuta sus fortalezas y debilidades en diferentes contextos de aplicaci\u00f3n.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "Spring Reactor y Akka son dos frameworks populares para implementar sistemas reactivos, aunque difieren en enfoque y alcance. Reactor, basado en el patr\u00f3n Reactor y centrado en flujos de datos, es ideal para aplicaciones intensivas en E/S como microservicios y APIs REST. Su fortaleza radica en su simplicidad y f\u00e1cil integraci\u00f3n con Spring. Sin embargo, su modelo de concurrencia basado en hilos puede ser menos eficiente para tareas de alta computaci\u00f3n.\n\nAkka, por otro lado, adopta el modelo Actor, promoviendo la concurrencia basada en mensajes y la tolerancia a fallos a trav\u00e9s de la supervisi\u00f3n.  Es adecuado para sistemas distribuidos complejos y aplicaciones con alta concurrencia como procesamiento de datos en tiempo real. Su mayor fortaleza es su robusta gesti\u00f3n de la concurrencia y la distribuci\u00f3n.  Sin embargo, su curva de aprendizaje es m\u00e1s pronunciada que la de Reactor, requiriendo un entendimiento m\u00e1s profundo de los actores y su ciclo de vida.  La elecci\u00f3n entre ambos depende del contexto de la aplicaci\u00f3n: Reactor para simplicidad en E/S, Akka para robustez en concurrencia distribuida.\n"}, {"numero": 9, "texto": "Dise\u00f1e una arquitectura reactiva para una aplicaci\u00f3n de comercio electr\u00f3nico que maneje un alto volumen de transacciones concurrentes, incluyendo la gesti\u00f3n de inventario, procesamiento de pagos y notificaciones al usuario.  Detalle las tecnolog\u00edas y patrones de dise\u00f1o que utilizar\u00eda y justifique sus elecciones.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "Para una aplicaci\u00f3n de comercio electr\u00f3nico de alto volumen, una arquitectura reactiva es crucial.  Utilizar\u00eda microservicios basados en Spring Boot con Spring WebFlux para manejar la concurrencia.  Cada microservicio, como gesti\u00f3n de inventario, procesamiento de pagos y notificaciones, operar\u00eda independientemente y se comunicar\u00eda de forma as\u00edncrona utilizando un broker de mensajes como Kafka.  Esto permite escalabilidad y resiliencia.  \n\nPara la gesti\u00f3n de inventario, emplear\u00eda el patr\u00f3n CQRS (Command Query Responsibility Segregation) para separar las operaciones de lectura y escritura, optimizando el rendimiento.  El procesamiento de pagos se integrar\u00eda con pasarelas de pago a trav\u00e9s de APIs RESTful, asegurando transacciones seguras. Las notificaciones al usuario se implementar\u00edan con un sistema de publicaci\u00f3n/suscripci\u00f3n utilizando WebSockets o Server-Sent Events para actualizaciones en tiempo real.  Finalmente, un gateway API como Spring Cloud Gateway gestionar\u00eda las solicitudes entrantes y dirigir\u00eda el tr\u00e1fico a los microservicios correspondientes.  Esta arquitectura reactiva, basada en eventos y no bloqueante, garantiza un rendimiento \u00f3ptimo y una alta disponibilidad incluso bajo picos de tr\u00e1fico.\n"}], "casos_uso": [{"numero": 10, "descripcion": "Demostrar que el sistema puede escalar el n\u00famero de workers para procesar un aumento en la tasa de ingesta de fragmentos y que la falla simulada de un worker no detiene el procesamiento por parte de otros.\n    -   **Sugerencias de herramientas o enfoques:** Akka Actors/Akka Streams (Scala/Java), RabbitMQ/Kafka para colas de mensajes, Kubernetes para orquestaci\u00f3n y escalado de workers. Considerar el patr\u00f3n de Backpressure.", "pregunta": "Desarrolle una soluci\u00f3n para el caso descrito anteriormente", "puntaje": 5, "respuestaAlumno": "", "archivoSubido": false, "respuestaProfesor": "Para demostrar la escalabilidad y la tolerancia a fallos en el procesamiento de fragmentos, se propone una soluci\u00f3n basada en Akka Streams y Kubernetes, utilizando Kafka como sistema de mensajer\u00eda.\n\nLa arquitectura consiste en un conjunto de workers implementados como Akka Actors, cada uno suscrito a un topic de Kafka donde se publican los fragmentos.  Akka Streams proporciona un framework reactivo para procesar los flujos de datos provenientes de Kafka.  La configuraci\u00f3n de `SupervisionStrategy` dentro del sistema Akka permite reiniciar autom\u00e1ticamente los actores en caso de fallo, garantizando la continuidad del procesamiento.\n\nEl escalado se gestiona a trav\u00e9s de Kubernetes.  Se define un Deployment para los workers, configurado con un Horizontal Pod Autoscaler (HPA). El HPA monitoriza el consumo de recursos de los pods (CPU o memoria) y ajusta autom\u00e1ticamente el n\u00famero de r\u00e9plicas (workers) en funci\u00f3n de la carga.  Un aumento en la tasa de ingesta de fragmentos se traduce en un mayor consumo de recursos, lo que dispara el HPA para escalar horizontalmente el n\u00famero de workers.\n\nKafka act\u00faa como buffer, desacoplando la ingesta de fragmentos del procesamiento.  Esto permite manejar picos de carga sin perder datos.  El patr\u00f3n de Backpressure se implementa mediante la configuraci\u00f3n del `bufferSize` en Akka Streams.  Si la tasa de procesamiento de un worker es menor que la tasa de ingesta, el buffer se llena, aplicando backpressure a Kafka y regulando el flujo de datos.\n\nPara simular la falla de un worker, se puede utilizar el comando `kubectl delete pod <nombre_del_pod>` en Kubernetes.  Esto eliminar\u00e1 un pod, simulando un fallo.  El HPA detectar\u00e1 la reducci\u00f3n en el n\u00famero de r\u00e9plicas y crear\u00e1 un nuevo pod para mantener el n\u00famero deseado de workers, demostrando la tolerancia a fallos del sistema.  El resto de workers continuar\u00e1n procesando los fragmentos sin interrupci\u00f3n, gracias a la naturaleza distribuida de Kafka y la gesti\u00f3n de fallos de Akka.  Esta arquitectura garantiza la escalabilidad y la resiliencia del sistema frente a fluctuaciones en la carga y fallos de los workers.\n", "archivoId": "anexo_284879_1748469930521", "archivoNombre": "Documentos-de-embarque.pdf", "archivoUrl": "https://cloud.appwrite.io/v1/storage/buckets/APPWRITE_BUCKET_DOCUMENTO_ANEXO_EXAMEN/files/anexo_284879_1748469930521/view?project=67e565df00172171560", "archivoTama\u00f1o": 168651, "archivoTipo": "application/pdf"}, {"numero": 11, "descripcion": "-   **Escenario pr\u00e1ctico detallado:** Un sistema de gesti\u00f3n de inventario para una cadena de supermercados con cientos de tiendas necesita procesar en tiempo real las ventas de cada caja registradora, actualizar el stock centralizado y generar autom\u00e1ticamente pedidos de reposici\u00f3n a los proveedores cuando", "pregunta": "Desarrolle una soluci\u00f3n para el caso descrito anteriormente", "puntaje": 5, "respuestaAlumno": "", "archivoSubido": false, "respuestaProfesor": "Para gestionar el inventario en tiempo real y la reposici\u00f3n autom\u00e1tica en una cadena de supermercados con cientos de tiendas, se propone una soluci\u00f3n basada en una arquitectura distribuida con los siguientes componentes:\n\n**1. Punto de Venta (POS):** Cada caja registradora contar\u00e1 con un sistema POS conectado a una base de datos local que almacena temporalmente las transacciones.  Al finalizar cada venta, el POS enviar\u00e1 los detalles de la transacci\u00f3n (productos vendidos, cantidades, etc.) a un servidor central a trav\u00e9s de una conexi\u00f3n segura.\n\n**2. Servidor Central de Inventario:** Este servidor recibir\u00e1 las actualizaciones de ventas de todos los POS en tiempo real.  Utilizar\u00e1 una base de datos centralizada para mantener un registro preciso del inventario global de la cadena.  Al recibir una actualizaci\u00f3n, el servidor decrementar\u00e1 el stock del producto correspondiente y verificar\u00e1 si se ha alcanzado el punto de reorden.\n\n**3. Sistema de Reposici\u00f3n Autom\u00e1tica:** Si el stock de un producto cae por debajo del punto de reorden predefinido, el sistema generar\u00e1 autom\u00e1ticamente una orden de compra al proveedor correspondiente.  Esta orden incluir\u00e1 la cantidad de producto a reponer, la informaci\u00f3n del proveedor y la tienda de destino.  El sistema tambi\u00e9n notificar\u00e1 al departamento de compras sobre la orden generada.\n\n**4. Interfaz con Proveedores:** El sistema se integrar\u00e1 con los sistemas de los proveedores para automatizar el proceso de pedido.  Las \u00f3rdenes de compra se enviar\u00e1n electr\u00f3nicamente a los proveedores, quienes podr\u00e1n confirmar la recepci\u00f3n y programar la entrega.\n\n**5. Sistema de Reportes:** El sistema generar\u00e1 reportes de inventario, ventas y reposici\u00f3n para facilitar la toma de decisiones.  Estos reportes permitir\u00e1n a la gerencia monitorear el desempe\u00f1o de las tiendas, identificar tendencias de ventas y optimizar los niveles de inventario.\n\n**Tecnolog\u00edas:** Se recomienda utilizar una base de datos distribuida como Apache Cassandra o Amazon DynamoDB para manejar el alto volumen de transacciones y asegurar la alta disponibilidad.  Para la comunicaci\u00f3n entre los POS y el servidor central, se puede utilizar un protocolo ligero como MQTT o un sistema de mensajer\u00eda como Kafka.\n\nEsta soluci\u00f3n permite una gesti\u00f3n eficiente del inventario, minimiza la posibilidad de desabastecimiento, reduce los costos de almacenamiento y mejora la satisfacci\u00f3n del cliente.\n"}]}, "createdAt": "2025-05-31T17:17:59.632735", "expiration": "2025-06-07T22:17:59.579Z", "publicAccess": true}