{"id": "7cbc0c4e", "examenData": {"examen_id": "273593", "nombre_examen": "Arquitecturas Reactivas", "tipo_examen": "Evaluaci\u00f3n", "fecha": "2025-06-16T20:44:56.245Z", "nombre_profesor": "Mariela Isabel Camargo Rom\u00e1n", "profesor_id": "16MI765", "preguntas_marcar": [], "preguntas_libres": [{"numero": 1, "texto": "Explique c\u00f3mo la programaci\u00f3n reactiva y el patr\u00f3n de dise\u00f1o Reactor facilitan la gesti\u00f3n de concurrencia y la escalabilidad en una arquitectura distribuida.  Incluya ejemplos de herramientas o frameworks que implementan este patr\u00f3n.", "puntaje": 1, "respuestaAlumno": "", "respuestaProfesor": "La programaci\u00f3n reactiva, basada en flujos de datos as\u00edncronos, simplifica la gesti\u00f3n de concurrencia al delegar el manejo de hilos a la biblioteca o framework subyacente.  El patr\u00f3n Reactor, una implementaci\u00f3n clave de este paradigma, utiliza un \u00fanico hilo de despacho para gestionar eventos, evitando bloqueos y mejorando el rendimiento en sistemas concurrentes.  Al desacoplar la producci\u00f3n y el consumo de datos, permite que los componentes reaccionen a eventos sin esperar respuestas s\u00edncronas, facilitando la escalabilidad horizontal.  \n\nEn arquitecturas distribuidas, el patr\u00f3n Reactor optimiza el uso de recursos al procesar m\u00faltiples solicitudes concurrentemente sin crear un hilo por cada una.  Esto reduce la sobrecarga y mejora la eficiencia, permitiendo escalar la aplicaci\u00f3n para manejar un mayor volumen de tr\u00e1fico.\n\nEjemplos de frameworks que implementan el patr\u00f3n Reactor incluyen Project Reactor (Java), RxJava, Vert.x y Node.js con sus APIs as\u00edncronas. Estas herramientas proveen abstracciones para manejar flujos de datos reactivos, simplificando el desarrollo de aplicaciones concurrentes y escalables.\n"}], "casos_uso": [{"numero": 1, "descripcion": "1. **Caso de Uso:** Sistema de Monitoreo de Sensores IoT en tiempo real.\n\n**Escenario:** Una empresa agr\u00edcola necesita monitorear la temperatura, humedad y luz de sus invernaderos.  Se recopilan datos de sensores IoT desplegados en cada invernadero y se deben mostrar alertas en tiempo real si alg\u00fan par\u00e1metro se sale de los rangos predefinidos.\n\n**Pregunta 1:** \u00bfC\u00f3mo se implementar\u00eda un sistema reactivo para procesar el flujo continuo de datos de los sensores y generar alertas en tiempo real, minimizando la latencia y asegurando la alta disponibilidad?\n\n", "pregunta": "**  Implementar un sistema reactivo que procese datos de sensores, genere alertas y las visualice en una interfaz de usuario.  El sistema debe ser escalable y tolerante a fallos.", "puntaje": 1, "respuestaAlumno": "", "archivoSubido": false, "respuestaProfesor": "Para implementar un sistema reactivo de monitoreo de sensores IoT que sea escalable y tolerante a fallos, se propone una arquitectura basada en microservicios utilizando las tecnolog\u00edas sugeridas.\n\n**1. Ingesti\u00f3n de datos:** Los sensores IoT env\u00edan datos continuamente a un cluster Kafka. Kafka proporciona alta disponibilidad y tolerancia a fallos gracias a su arquitectura distribuida.  Cada tipo de dato (temperatura, humedad, luz) puede tener su propio topic en Kafka para facilitar el procesamiento independiente y escalabilidad.\n\n**2. Procesamiento de datos:**  Un servicio implementado con Spring Reactor consume los datos de Kafka.  Spring Reactor permite procesar el flujo continuo de datos de forma reactiva y eficiente.  Dentro de este servicio, se definen los rangos predefinidos para cada par\u00e1metro.  Se utiliza un operador `filter` para identificar los datos que se salen de los rangos y generar eventos de alerta.\n\n**3. Almacenamiento de alertas:** Las alertas generadas se almacenan en Redis, una base de datos in-memory que proporciona baja latencia para la lectura y escritura de datos.  Esto permite una respuesta r\u00e1pida a las alertas.  Se puede utilizar una estructura de datos como una lista o un conjunto ordenado para almacenar las alertas y facilitar su acceso.\n\n**4. Visualizaci\u00f3n:**  Grafana se utiliza para visualizar las alertas y los datos de los sensores en tiempo real.  Grafana se conecta a Redis para obtener las alertas y puede conectarse directamente a Kafka o a una base de datos de series temporales para visualizar los datos hist\u00f3ricos de los sensores.  Se crean dashboards personalizados para mostrar la informaci\u00f3n relevante para los usuarios.\n\n**5. Resiliencia:**  La resiliencia se logra mediante la replicaci\u00f3n de los datos en Kafka y Redis. Si un nodo falla, otro puede tomar su lugar sin interrupci\u00f3n del servicio.  Spring Reactor proporciona mecanismos para gestionar errores y reintentos en el procesamiento de datos.  Adem\u00e1s, se pueden implementar mecanismos de fallback para utilizar valores predeterminados en caso de que un sensor falle.\n\n**6. Escalabilidad:**  La escalabilidad se logra mediante la adici\u00f3n de m\u00e1s nodos a los clusters de Kafka y Redis.  El servicio de procesamiento de datos con Spring Reactor tambi\u00e9n se puede escalar horizontalmente para manejar un mayor volumen de datos.  La arquitectura de microservicios permite escalar cada componente del sistema de forma independiente.\n\nEsta arquitectura proporciona un sistema reactivo, escalable y tolerante a fallos para el monitoreo de sensores IoT en tiempo real. La combinaci\u00f3n de Kafka, Spring Reactor, Redis y Grafana ofrece una soluci\u00f3n robusta y eficiente para el procesamiento de datos, la generaci\u00f3n de alertas y la visualizaci\u00f3n en tiempo real.\n"}]}, "createdAt": "2025-06-16T15:44:56.285511", "expiration": "2025-06-23T20:44:56.245Z", "publicAccess": true}